# 7장. 고급 트랜잭션과 스크립팅 <!-- omit in toc -->

> 📖 원문: [Mastering Bitcoin 2nd Endition - Chapter 07. Advanced Transactions and Scripting](https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch07.asciidoc)

### 목차

- [개요](#개요)
- [다중 서명](#다중-서명)
  - [CHECKMULTISIG 실행 시 버그](#checkmultisig-실행-시-버그)
- [Pay-to-Script-Hash (P2SH)](#pay-to-script-hash-p2sh)
  - [P2SH 주소](#p2sh-주소)
  - [P2SH의 장점](#p2sh의-장점)
  - [상환 스크립트와 유효성 검사](#상환-스크립트와-유효성-검사)
- [데이터 기록 출력 (`RETURN`)](#데이터-기록-출력-return)
- [타임락](#타임락)
  - [트랜잭션 잠금 시간 (`nLocktime`)](#트랜잭션-잠금-시간-nlocktime)
    - [트랜잭션 잠금 시간의 한계](#트랜잭션-잠금-시간의-한계)
  - [`CHECKLOCKTIMEVERIFY` (CLTV)](#checklocktimeverify-cltv)
  - [상대적 타임락](#상대적-타임락)
  - [`nSequence`를 사용한 상대적 타임락](#nsequence를-사용한-상대적-타임락)
    - [`nSequence`의 원래 의미](#nsequence의-원래-의미)
    - [합의에 의해 강제되는 상대적 타임락으로서의 `nSequence`](#합의에-의해-강제되는-상대적-타임락으로서의-nsequence)
  - [CSV를 사용한 상대적 타임락](#csv를-사용한-상대적-타임락)
  - [Median-Time-Past](#median-time-past)
  - [수수료 저격에 대한 시간 잠금 방어](#수수료-저격에-대한-시간-잠금-방어)
- [조건절을 포함하는 스크립트](#조건절을-포함하는-스크립트)
  - [`VERIFY` 옵코드와 조건절](#verify-옵코드와-조건절)
  - [스크립트에서 흐름 제어하기](#스크립트에서-흐름-제어하기)
- [복잡한 스크립트의 예](#복잡한-스크립트의-예)
- [세그윗 (Segrated Witness)](#세그윗-segrated-witness)
  - [왜 세그윗인가?](#왜-세그윗인가)
  - [세그윗 동작 방식](#세그윗-동작-방식)
  - [소프트 포크 (이전 버전과의 호환성)](#소프트-포크-이전-버전과의-호환성)
  - [세그윗 출력 및 트랜잭션 예시](#세그윗-출력-및-트랜잭션-예시)
    - [Pay-to-Witness-Public-Key-Hash (P2WPKH)](#pay-to-witness-public-key-hash-p2wpkh)
    - [P2WPKH의 지갑 구성](#p2wpkh의-지갑-구성)
    - [Pay-to-Witness-Script-Hash (P2WSH)](#pay-to-witness-script-hash-p2wsh)
    - [P2WPKH와 P2WSH 구분하기](#p2wpkh와-p2wsh-구분하기)
  - [세그윗으로 업그레이드하기](#세그윗으로-업그레이드하기)
    - [P2SH에 세그윗 포함하기](#p2sh에-세그윗-포함하기)
    - [P2SH(P2WPKH)](#p2shp2wpkh)
    - [P2SH(P2WSH)](#p2shp2wsh)
    - [세그윗 주소](#세그윗-주소)
    - [트랜잭션 식별자](#트랜잭션-식별자)
  - [세그윗의 새로운 서명 알고리즘](#세그윗의-새로운-서명-알고리즘)
  - [세그윗의 경제적 동기부여](#세그윗의-경제적-동기부여)

---

<br>

## 개요

이 장에서는 
- 다중 서명 스크립트를 다룬다.
- P2SH(Pay-to-Script-Hash)를 다룬다. P2SH는 복잡한 스크립트의 세계를 열어주는 두 번째로 일반적인 트랜잭션 스크립트이다. 
- 타임락을 통해 비트코인에 시간 차원을 추가하는 새로운 스크립트 연산자를 다룬다. 
- 트랜잭션 구조의 변화인 세그윗(Segregated Witness)에 대해 다룬다.

<br>

## 다중 서명

- 스크립트에 N개의 공개키가 기록되고 그 중 최소 M개의 키가 서명을 제공해야 잠금 해제할 수 있는 조건을 설정한다.
- 이를 M-of-N 방식이라 하며, 여기서 N은 총 키 수이고 M은 유효성 검사에 필요한 서명의 임계값이다.
- 현재 표준 다중 서명 스크립트는 나열된 공개키가 최대 3개로 제한되어 있으므로, 1-of-1 다중 서명부터 3-of-3 다중 서명까지 그 범위 내에서 어떤 조합이든 가능하다.
- 3개의 키 제한은 표준 다중 서명 스크립트에만 적용되며, P2SH(Pay-to-Script-Hash) 스크립트로 래핑된 다중 서명 스크립트에는 적용되지 않는다는 점에 유의하자. (P2SH 다중 서명 스크립트는 15개의 키로 제한되어 있다.)
- M-of-N 다중 서명 조건을 설정하는 잠금 스크립트의 일반적인 형태는 다음과 같다.
  ```
  M <Public Key 1> <Public Key 2> ... <Public Key N> N CHECKMULTISIG
  ```
- 2-of-3 다중 서명 조건을 설정하는 잠금 스크립트는 다음과 같다.
  ```
  2 <Public Key A> <Public Key B> <Public Key C> 3 CHECKMULTISIG
  ```
- 위 잠금 스크립트는 나열된 3개의 공개키에 해당하는 개인키로 서명한 두 개의 서명 조합을 포함하는 해제 스크립트로 충족된다.
  ```
  <Signature B> <Signature C>
  ```
- 두 스크립트를 합쳐서 유효성 검사 스크립트를 구성한다.
  ```
  <Signature B> <Signature C> 2 <Public Key A> <Public Key B> <Public Key C> 3 CHECKMULTISIG
  ```

<br>

### CHECKMULTISIG 실행 시 버그

- CHECKMULTISIG가 실행될 때 스택의 M+N+2 개의 항목을 매개변수로 사용해야 한다.
- 그러나 버그로 인해 CHECKMULTISIG는 한 개를 더 추가 출력한다.
- 유효성 검사 스크립트
  ```
  <Signature B> <Signature C> 2 <Public Key A> <Public Key B> <Public Key C> 3 CHECKMULTISIG
  ```
  - CHECKMULTISIG 연산자는 스택에서 항목 하나 N(= 3)을 꺼낸다.
  - 3개의 항목을 꺼낸다.
  - 스택에서 항목 하나 M(= 2)을 꺼낸다.
  - 이 시점에서 2개의 항목을 꺼내야하지만 CHECKMULTISIG 버그로 *M+1개*가 꺼내진다.
  - 추가로 꺼낸 값은 서명 확인 시 무시되기 때문에 직접적인 영향을 미치지 않지만, 빈 스택에서 항목을 꺼내려고 할 때 스택 오류로 인한 실패가 발생하므로 임의의 추가 값이 필요하다.
  - 추가 항목은 무시되므로 아무 값이나 사용할 수 있지만 일반적으로 0이 사용된다. 
- 이 버그가 합의 규칙의 일부가 되어 올바른 스크립트 유효성 검사 스크립트는 다음과 같다. 
  ```
  0 <Signature B> <Signature C> 2 <Public Key A> <Public Key B> <Public Key C> 3 CHECKMULTISIG
  ``` 
  - 즉, `0 <Signature B> <Signature C>`가 해제 스크립트로 사용된다.
- 이제부터 다중서명 해제 스크립트의 처음에 0이 표시될 것이며, 이는 합의 규칙이 된 버그에 대한 해결 방법을 나타낸다.

<br>

## Pay-to-Script-Hash (P2SH)

- P2SH는 복잡한 트랜잭션 스크립트 사용을 크게 간소화한 방법이며 2012년에 새롭게 도입되었다. 
- 이 책의 예제 두바이의 전자제품 수입업체 모하메드의 회사 사례를 들어보자.
  - 모하메드는 비트코인의 다중 서명 기능을 기업 계정에 광범위하게 사용한다.
  - 모든 고객 결제에 다중 서명 스크립트를 사용하며, 고객이 지불한 결제는 모하메드, 그의 세 명의 파트너, 백업키를 가진 변호사, 이렇게 다섯 중 최소 둘의 서명이 있어야 한다. 
  - 잠금 스크립트는 다음과 같다.
    ```
    2 <Mohammed's Public Key> <Partner1 Public Key> <Partner2 Public Key> <Partner3 Public Key> <Attorney Public Key> 5 CHECKMULTISIG
    ```
<br>

- 아무리 다중 서명 스크립트가 강력하다 해도 다음과 같은 단점이 있다.  
  - 모든 고객이 결제 전 이 스크립트를 전달받아야 한다.
  - 고객은 이 스크립트로 지정한 거래 스크립트를 생성할 수 있는 특수 비트코인 지갑 소프트웨어를 사용해야 하고, 거래를 생성하는 방법도 이해해야 한다. 
  - 이 스크립트에는 매우 긴 공개키가 포함되어 있기 때문에 결과 트랜잭션은 단순 결제 트랜잭션보다 약 5배 더 커질 것이다. 이는 고스란히 고객의 수수료 부담이 된다. 
  - 대용량 트랜잭션 스크립트가 모든 풀 노드의 RAM에 설정된 UTXO에 저장되어 소비될 때까지 유지된다. 
  
<br>

- P2SH는 이러한 단점을 해결하고 비트코인 주소로 결제하는 것처럼 복잡한 스크립트를 사용할 수 있도록 하기 위해 개발되었다.
- P2SH 결제를 사용하면 복잡한 잠금 스크립트가 암호화 해시인 디지털 지문으로 대체된다.
- UTXO를 사용하려는 트랜잭션이 제시될 때 해제 스크립트 외에도 이 해시와 일치하는 스크립트를 제시해야 한다.
- P2SH는 "이 해시와 일치하는 스크립트에 지불함"을 의미하며, 여기서 스크립트란 나중에 이 출력이 사용될 시점(상환 시점)에 표시되는 스크립트를 말한다. 

<br>

- P2SH 트랜잭션에서 해시로 대체되는 잠금 스크립트는 상환(redemption) 시점에 시스템에 나타나기 때문에 상환 스크립트(redeem script)라 한다.
- 복잡한 스크립트와 P2SH를 비교해보자.

<br/>
  
<table>
    <tbody>
        <tr>
            <td>잠금 스크립트</td>
            <td>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</td>
        </tr>
        <tr>
            <td>해제 스크립트</td>
            <td>0 Sig1 Sig2</td>
        </tr>
    </tbody>
    <caption style="caption-side: bottom">표 1. 복잡한 스크립트</caption>
</table>

<table>
    <tbody>
        <tr>
            <td>상환 스크립트</td>
            <td>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</td>
        </tr>
        <tr>
            <td>잠금 스크립트</td>
            <td>HASH160 <20-byte hash of redeem script> EQUAL</td>
        </tr>
        <tr>
            <td>해제 스크립트</td>
            <td>0 Sig1 Sig2 <&zwj;redeem script></td>
        </tr>
    </tbody>
    <caption style="caption-side: bottom">표 2. P2SH</caption>
</table>

<br>

- 표에서 볼 수 있듯이 P2SH를 사용하면 복잡한 스크립트가 잠금 스크립트에 표시되지 않는다. 잠금 스크립트에는 해시만 있고, 상환 스크립트는 나중에 출력이 소비될 시점에 해제 스크립트의 일부로 제공된다. 

<br>

- P2SH를 이용하면 모하메드의 매우 긴 잠금 스크립트도 `HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL`처럼 간결해진다. 
  - `54c557e07dde5bb6cb791c7a540e0a4796f5e97e`는 상환 스크립트 `2 <Mohammed's Public Key> <Partner1 Public Key> <Partner2 Public Key> <Partner3 Public Key> <Attorney Public Key> 5 CHECKMULTISIG`의 이중 해시 결과이다.
- 이 출력을 사용하려면 상환 스크립트와 해제 스크립트를 제시해야 한다. 
  - 상환 스크립트: `<2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG>`
  - 해제 스크립트: `0 <Sig1> <Sig2> <redeem script>`
- 먼저, 상환 스크립트를 잠금 스크립트와 비교하여 해시가 일치하는지 확인한다.
  ```
  <2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG> HASH160 <redeem scriptHash> EQUAL
  ```
- 해시가 일치하면 해제 스크립트가 실행된다. 
  ```
  0 <Sig1> <Sig2> 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG
  ```

<br>

### P2SH 주소

- P2SH는 BIP-13에 정의된 대로 스크립트 해시를 주소로 인코딩한다. 
- 이는 20바이트 길이의 해시를 Base58Check로 인코딩한다. P2SH 주소는 버전 접두사 "5"를 사용하므로 "3"으로 시작하는 Base58Check 인코딩 주소가 된다.
- 따라서, 모하메드의 예에서 고객에게 복잡한 스크립트를 제공하는 것이 아닌 3으로 시작하는 주소를 제공할 수 있다. 

<br>

### P2SH의 장점

- 트랜잭션 출력의 복잡한 스크립트가 해시로 대체되어 트랜잭션 크기가 작아진다.
- 발신자는 P2SH를 구현하기 위한 복잡한 기술을 필요로 하지 않는다.
- P2SH 스크립트 구성의 부담을 발신자가 아닌 수신자에게 전가한다.
- P2SH는 긴 스크립트로 인한 데이터 저장 부담을 출력에서 입력으로 전환한다. (UTXO 데이터를 유지하지 않아도 된다.)
- P2SH는 긴 스크립트에 대한 데이터 저장 부담을 현재(결제)에서 미래(사용 시점)로 유예한다.
- P2SH는 긴 스크립트의 높은 트랜잭션 수수료 비용을 발신자에서 이를 사용하기 위해 긴 상환 스크립트를 포함해야 하는 수신자에게로 이전한다.

<br>

### 상환 스크립트와 유효성 검사

- 비트코인 코어 클라이언트 버전 0.9.2부터 P2SH를 지원한다. 
- P2SH의 상환 스크립트에 P2SH를 넣을 수는 없다. 
- 기술적으로 상환 스크립트에 `RETURN` 유형을 포함할 수 있지만, 유효성 검사 중에 `RETURN`을 실행하면 트랜잭션이 유효하지 않은 것으로 표시되므로 실제 사용은 불가능하다.
- P2SH 출력을 사용하려고 시도하기 전까지는 상환 스크립트가 네트워크에 표시되지 않으므로 상환 스크립트 자체가 잘못된 스크립트여서 나중에 사용할 수 없는 스크립트일지라도 정상 처리된다는 점에 유의하자. 

<br>

## 데이터 기록 출력 (`RETURN`)

- 많은 개발자가 트랜잭션 스크립트 언어를 사용하여 디지털 공증 서비스, 주식 증서, 스마트 계약과 같은 애플리케이션에서 시스템의 보안(security)과 복원력(resilience)을 활용하려고 시도해왔다.
- 비트코인 결제와 무관한 데이터를 저장하기 위해 비트코인 블록체인을 사용하는 것은 논란의 여지가 있는 주제이며 많은 개발자는 이러한 사용을 악용이라고 생각한다. 
  - 이들은 결제 데이터가 아닌 트랜잭션이 '블록체인 비대화'를 유발하여 전체 비트코인 노드를 운영하는 사람들에게 디스크 스토리지 비용 부담을 증가시킨다고 주장한다.
  - 이는 사용할 수 없는 UTXO를 생성하는데 이로 인해 UTXO 데이터베이스의 크기가 영원히 증가한다.
- 한편 이를 블록체인 기술의 강력한 기능을 보여주는 것으로 보고 실험을 장려하는 견해도 있다.

<br>

- 비트코인 코어 클라이언트 버전 0.9에서는 `RETURN` 연산자를 도입하여 이 문제에 타협했다.
- 개발자는 `RETURN` 연산자를 통해 트랜잭션 출력에 80바이트의 결제가 아닌 데이터를 추가할 수 있다. 
  - `RETURN` 연산자는 명시적으로 증명할 수 있는 출력을 생성하며, 이는 UTXO 세트에 저장할 필요가 없다. 
  - `RETURN` 출력은 블록체인에 기록되므로 디스크 공간을 소비하고 블록체인의 크기를 늘리지만, UTXO 세트에는 저장되지 않으므로 UTXO 메모리 풀을 부풀리거나 풀 노드에 더 비싼 RAM 비용을 부담시키지 않는다.
- `RETURN` 스크립트: `RETURN <data>`
  - 데이터 부분은 80바이트로 제한되며, 대부분 SHA256의 결과(32바이트)와 같은 해시를 나타낸다. (이후 40바이트로 제한되었으나 다시 80바이트로 증가했다.)
- 많은 애플리케이션은 데이터 앞에 접두사를 넣어 트랜잭션 용도를 식별하도록 한다. 예를 들어, [Proof of Existence](https://proofofexistence.com/) 디지털 공증 서비스는 16진수로 44 4f 43 50 52 4f 4f 46으로 인코딩된 ASCII인 8바이트 접두사 DOCPROOF를 사용한다.
- 표준 트랜잭션에서 하나의 `` 출력만 포함할 수 있으며, 다른 유형의 출력도 함께 포함할 수 있다. 
- 비트코인 코어 0.10부터 두 가지 새로운 옵션이 추가되었다. datacarrier 옵션은 `RETURN` 트랜잭션의 릴레이와 마이닝을 제어하며 기본값은 '1'로 `RETURN` 트랜잭션을 허용한다. `RETURN` 스크립트의 최대 크기를 바이트 단위로 지정하는 숫자를 인자로 받으며 기본값은 83이다.(최대 80바이트 데이터 + 1바이트 `RETURN` 옵코드 + 2바이트 PUSHDATA 옵코드)

<br>

## 타임락

- 타임락은 특정 시점 이후에만 지출을 허용하는 트랜잭션 혹은 출력을 제한하는 기능이다.
- 비트코인에는 처음부터 트랜잭션의 ``nLocktime`` 필드가 있었고 이는 트랜잭션 수준의 타임락 기능이다.
- 2015년 말, 2016년 중반에 두 가지 새로운 타임락 기능이 도입되어 UTXO 수준의 타임락을 제공한다. (``CHECKLOCKTIMEVERIFY``와 `CHECKSEQUENCEVERIFY`)
- 타임락은 트랜잭션과 자금을 미래의 날짜에 잠그는 데 유용하다. 더 중요한 것은 타임락이 비트코인 스크립팅을 시간 차원으로 확장하여 복잡한 스마트 컨트랙트를 위한 문을 열어준다는 것이다.

<br>

### 트랜잭션 잠금 시간 (`nLocktime`)

- 트랜잭션 잠금 시간은 트랜잭션이 유효하고 네트워크에서 릴레이되거나 블록체인에 추가될 수 있는 가장 이른 시간을 정의하는 트랜잭션 수준 설정(트랜잭션 데이터 구조의 필드)이다.
- 비트코인 코어 코드에 사용되는 변수 이름을 따서 `nLocktime`이라고도 한다. 
  - 대부분의 트랜잭션에서는 즉각적인 전파 및 실행을 나타내기 위해 0으로 설정된다. 
  - `nLocktime`이 0이 아닌 5억 미만인 경우, 블록 높이로 해석되며, 이는 지정된 시간 이전에는 트랜잭션이 유효하지 않으며 지정된 블록 높이 이전에 릴레이되거나 블록체인에 포함되지 않음을 의미한다. 
  - 5억 보다 크거나 같으면 유닉스 에포크 타임스탬프(1970년 1월 1일 이후 초)로 해석되며 지정된 시간 이전에는 트랜잭션이 유효하지 않음을 의미한다. 
- 미래의 블록 또는 시간을 지정하는 `nLocktime`이 있는 트랜잭션은 트랜잭션이 만들어진 시스템(노드)에 보관되어야 하며, 트랜잭션이 유효해진 후에만 비트코인 네트워크로 전송된다. 

#### 트랜잭션 잠금 시간의 한계

- `nLocktime`은 일부 출력을 미래에 사용할 수 있게 해주지만, 그 시간까지 출력을 사용할 수 없게 만든다. 
- 예를 들어, 앨리스가 자신의 출력 중 하나에 트랜잭션 잠금 시간을 미래 3개월로 설정하고 밥의 주소로 보내는 트랜잭션에 서명 후 밥에게 보낸다. 
- 밥은 3개월이 경과할 때까지 자금을 상환하기 위해 트랜잭션을 전송할 수 없다. 밥은 3개월 후에야 트랜잭션을 전송할 수 있다.
- 한편, 앨리스는 다른 트랜잭션을 생성하여 잠금 시간 없이 (3개월이 경과하기 전) 동일한 입력을 이중으로 사용할 수 있다. 
- 다시말해 밥이 자금을 받을 수 있다는 보장이 없다! 밥이 자금을 받을 수 있다는 것을 확신하려면 트랜잭션이 아닌 UTXO 자체에 타임락 제한을 걸어 잠금 스크립트의 일부로 설정해야 한다. 

<br>

### `CHECKLOCKTIMEVERIFY` (CLTV)

- 2015년 12월, 소프트 포크 업그레이드로 새로운 형태의 타임락이 비트코인에 도입되었다. 
- BIP-65의 명세에 따라, 스크립트 언어에 CLTV(`CHECKLOCKTIMEVERIFY`)라는 새로운 스크립트 연산자가 추가되었다. 
- 출력의 상환 스크립트에 CLTV 연산 코드를 추가하면 지정된 시간이 경과한 후에만 출력을 사용할 수 있도록 제한할 수 있다.
- CLTV 연산 코드는 하나의 파라미터를 입력으로 받으며, 이 파라미터는 `nLocktime`과 동일한 형식의 숫자(블록 높이 또는 유닉스 에포크 시간)로 표현된다. (VERIFY 접미사로 표시된 것처럼 CLTV는 결과가 FALSE인 경우 스크립트 실행을 중지하고 TRU인 경우 계속 실행한다.)

- CLTV로 출력을 잠그는 예
  - 일반적인 P2PKH 스크립트
    ```
    DUP HASH160 <Bob's Public Key Hash> EQUALVERIFY CHECKSIG
    ```
  - 지금부터 3개월 후와 같이 특정 시점에 출력을 잠그려는 상환 스크립트가 포함된 P2SH 스크립트
    ```
    <now + 3 months> CHECKLOCKTIMEVERIFY DROP DUP HASH160 <Bob's Public Key Hash> EQUALVERIFY CHECKSIG
    ```
    - `<now + 3 months>`: 트랜잭션이 채굴된 시점으로부터 3개월 후로 추정되는 블록 높이 또는 시간 값.(현재 블록 높이 + 12,960 블록 또는 현재 유닉스 에포크 시간 + 7,760,000 초)
    - `DROP`: 뒤에서 설명

- 밥이 이 UTXO를 사용하려고 하면, 밥은 이 UTXO를 입력으로 참조하는 트랜잭션을 구성한다. 
- 밥은 앨리스가 설정한 타임락보다 크거나 같도록 트랜잭션 `nLocktime`을 설정한 후 브로드캐스팅한다. 
- 밥의 트랜잭션은 다음과 같이 평가된다.
  - 앨리스가 설정한 `CHECKLOCKTIMEVERIFY` 매개변수가 밥의 트랜잭션 `nLocktime` 보다 작거나 같으면 스크립트 실행이 계속된다. 그렇지 않으면 스크립트 실행이 중지되고 트랜잭션이 유효하지 않은 것으로 간주된다.
- 더 정확히 다음과 같은 경우 `CHECKLOCKTIMEVERIFY`가 실패하고 실행이 중단되어 *트랜잭션이 유효하지 않은 것*으로 표시된다. (출처: BIP-65)
  - 스택이 비어 있거나
  - 스택의 최상위 항목이 0보다 작거나
  - 최상위 스택 항목의 타임락 유형과 `nLocktime` 필드가 동일하지 않거나
  - 최상위 스택 항목이 트랜잭션의 `nLocktime` 필드보다 크거나
  - 입력의 `nSequence` 필드가 0xffffffff인 경우

- 실행 후 CLTV가 만족되면 그 이전의 시간 매개변수는 스택의 최상위 항목으로 남아 있으며, 이후 스크립트 옵코드의 올바른 실행을 위해 `DROP`을 사용하여 삭제해야 할 수 있다. 이러한 이유로 스크립트에서 `CHECKLOCKTIMEVERIFY` 뒤에 `DROP`이 오는 것을 종종 볼 수 있다.
- CLTV와 함께 `nLocktime`을 사용하면 트랜잭션 잠금 시간 제한에 설명된 시나리오가 변경된다. 밥은 3개월의 잠금 시간이 만료되기 전까지 자금을 사용할 수 없고, 밥의 키로 잠겨있기 때문에 앨리스도 자금을 사용할 수 없다.

<br>

### 상대적 타임락

- `nLocktime`과 CLTV는 모두 절대 시점을 지정한다는 점에서 절대적 타임락이다. 
- 반면 블록체인에서 출력이 확인된 후 경과된 시간을 지정하는 상대적 타임락이 있다.
- 상대적 타임락은 두 개 이상의 상호 의존적인 트랜잭션의 체인을 오프체인으로 유지하면서, 이전 트랜잭션의 확인 후 경과 시간에 따라 한 트랜잭션에 시간 제약을 부과할 수 있다는 점에서 유용하다. 이는 양방향 상태 채널과 라이트닝 네트워크에서 특히 유용하며, [state_channels]에서 살펴본다. # TODO: 
- 상대적 타임락도 트랜잭션 수준과 스크립트 수준 연산 코드로 구현된다. 
  - 트랜잭션 입력에 설정되는 트랜잭션 필드인 `nSequence` (BIP-68: 합의에 의해 강제되는 시퀀스 번호를 사용한 상대적 잠금 시간)
  - 스크립트 수준 CHECKSEQUENCEVERIFY(CSV) 연산 코드 (BIP-112: CHECKSEQUENCEVERIFY)
- BIP-68과 BIP-112는 합의 규칙에 대한 소프트 포크 업그레이드로 2016년 5월에 활성화되었다.

<br>

### `nSequence`를 사용한 상대적 타임락

- 트랜잭션 입력의 `nSequence` 필드를 설정하여 상대적 시간 잠금을 설정할 수 있다.

#### `nSequence`의 원래 의미

- 원래 `nSequence` 필드는 멤풀에서 트랜잭션을 수정할 수 있도록 의도되었지만 제대로 구현되지 않았다. 
  - 이 용도로 사용되었을 때, `nSequence` 값이 $2^{32} - 1$ (0xFFFFFFFF) 미만인 입력을 포함하는 트랜잭션은 아직 "완료되지 않은" 트랜잭션임을 나타낸다. (동일한 입력을 더 높은 `nSequence` 값으로 사용하는 다른 트랜잭션으로 대체될 때까지 멤풀에 보관된다.)
  - 입력값이 0xFFFFFFFF인 트랜잭션이 수신되면 해당 트랜잭션은 "최종 완료"된 것으로 간주되어 채굴된다.
- 타임락을 사용하지 않는 트랜잭션에서 `nSequence`의 값은 관례적으로 0xFFFFFFFF로 설정된다.

- `nLocktime` 또는 `CHECKLOCKTIMEVERIFY`를 사용하는 트랜잭션의 경우, 타임락 보호 효과가 발휘되려면 아래 설명과 같이 `nSequence` 값을 $2^{31}$ 미만으로 설정되어야 한다.

#### 합의에 의해 강제되는 상대적 타임락으로서의 `nSequence`

- BIP-68이 활성화된 이후, `nSequence` 값이 $2^{31}$보다 작은(비트 1<<31이 설정되지 않은) 입력이 포함된 모든 트랜잭션에 새로운 합의 규칙이 적용되었다.
- 프로그래밍적으로 이는 가장 큰 비트(비트 1<<31)가 설정되지 않은 경우, "상대적 잠금 시간"을 의미하는 플래그를 의미하고, 그렇지 않은 경우, `nSequence` 값은 `CHECKLOCKTIMEVERIFY`, `nLocktime`, Opt-In-Replace-By-Fee 활성화 및 기타 향후 개발과 같은 다른 용도로 예약된다.

- `nSequence` 값이 $2^{31}$ 보다 작은 트랜잭션 입력은 상대적 타임락이 있는 것으로 해석한다. 
  - `nSequence` 상대적 타임락이 30블록인 입력이 있는 트랜잭션은 입력에 참조된 UTXO가 채굴된 시점으로부터 최소 30블록이 경과한 경우에만 유효하다.
  - 트랜잭션에는 타임락이 설정된 입력(`nSequence` < $2^{31}$)과 상대적인 타임락이 설정되지 않은 입력(`nSequence` >= $2^{31}$)이 모두 포함될 수 있다.

- `nSequence` 값은 블록 또는 초 단위로 지정된다.
  - 타입 플래그는 23번째 비트(즉, 값 1<<22)로 설정된다. 
  - 플래그가 설정되어 있으면 `nSequence` 값은 512초의 배수로 해석된다.
  - 설정되지 있지 않으면 `nSequence` 값은 블록 수로 해석된다.

- `nSequence`가 상대적 타임락인 경우 최하위 16비트만 고려한다. 플래그가 평가되면 `nSequence` 값은 일반적으로 16비트 마스크로 "마스킹"된다(예: `nSequence` & 0x0000FFFF).

<br>

<figure>
<img src="https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0701.png" style="width:70%">
<br>그림 1. `nSequence` 인코딩의 BIP-68 정의(출처: BIP-68)
</figure>

<br>
<br>

### CSV를 사용한 상대적 타임락

- `nSequence` 값을 활용하는 상대적 시간 잠금을 위한 스크립트 옵코드를 `CHECKSEQUENCEVERIFY`, 줄여서 CSV라 한다. 
- UTXO의 상환 스크립트를 평가할 때 CSV 옵코드는 입력된 `nSequence` 값이 CSV 매개변수보다 크거나 같은 트랜잭션에서만 지출을 허용한다. 
- CLTV와 마찬가지로 CSV의 값은 해당 `nSequence` 값의 형식과 일치해야 한다. 
- CSV를 사용한 상대적 타임락은 여러 개의 체인화된 트랜잭션이 생성되고 서명되었지만 "오프체인"으로 유지되고  전파되지 않을 때 특히 유용하다. 라이트닝 네트워크에서 이러한 적용 사례를 볼 수 있다. 

<br>

### Median-Time-Past

- 상대적 타임락 활성화의 일환으로, 타임락(절대 및 상대)을 설정하기 위한 시간 계산 방식도 변경되었다. 
- 비트코인에서는 벽 시간(wall time, 벽 시계에서 볼 수 있는 실제 시간. 컴퓨터 시스템에 따른 부정확할 수 있는 시간과 대조됨.)과 합의 시간 사이에 미묘하지만 매우 중요한 차이가 있다. 
- 탈중앙화된 네트워크인 비트코인은 각 참여자가 각자의 시간 관점을 가지고 있다. 네트워크의 이벤트는 즉각적으로 발생하지 않으며, 지연 시간은 각 노드의 관점에서 고려되어야 한다. 결국 모든 것이 동기화되어 공동 원장이 만들어진다. 비트코인은 *과거*(past)에 존재했던 원장의 상태에 대해 10분마다 합의에 도달한다.
- 블록 헤더의 타임스탬프는 채굴자가 설정한다. 합의 규칙에는 노드 간 시계 정확도 차이를 고려하기 위해 어느 정도의 오차가 허용되어 있다. 그러나 이는 채굴자가 수수료를 벌기 위해 아직 만기되지 않은 타임락 트랜잭션을 포함시키게 하기도 한다.
- 이러한 요인을 제거하고 타임락 보안을 강화하기 위한 BIP와 상대적 타임락에 대한 BIP가 동시에 제안되고 활성화되었다. BIP-113으로 Median-Time-Past라는 새로운 합의 시간 측정을 정의한다.
- Median-Time-Past는 지난 11개 블록의 타임스탬프를 가져와 중앙값을 구하여 계산한다. 이 중간값이 합의 시간이 되어 모든 타임락 계산에 사용된다. 
- 과거 약 2시간의 중간값을 취함으로써 한 블록의 타임스탬프가 미치는 영향이 줄어든다. 11개의 블록을 통합하면 아직 만기되지 않은 타임락이 있는 트랜잭션으로 수수료를 얻기 위한 의도를 가진 채굴자가 타임스탬프에 영향력을 행사할 수 없게 된다.
- Median-Time-Past는 `nLocktime`, CLTV, `nSequence` 및 CSV에 대한 시간 계산 구현을 변경한다. Median-Time-Past로 계산된 합의 시간은 항상 벽시계 시간보다 약 1시간 늦다. 타임락 트랜잭션을 생성하려는 경우 `nLocktime`, `nSequence`, CLTV 및 CSV에서 인코딩하기 위한 기대값을 추정할 때 이를 고려해야 한다.

<br>

### 수수료 저격에 대한 시간 잠금 방어

- 수수료 저격(fee sniping)은 이론적인 공격 시나리오로, 채굴자가 수익성을 극대화하기 위해 과거 블록을 재작성하여 미래 블록에서 수수료가 높은 트랜잭션을 '저격'하는 것을 말한다.
- 현재로서는 블록 보상이 블록당 총 수수료보다 훨씬 높기 때문에 이 공격은 수익성이 높지 않지만 미래 어느 시점에서는 거래 수수료가 채굴 보상의 대부분(또는 채굴 보상 전체)을 차지하게 되면 이 시나리오는 피할 수 없게 된다.
- 수수료 저격 공격을 방지하기 위해 비트코인 코어는 트랜잭션을 생성할 때 기본적으로 `nLocktime`을 사용하는 트랜잭션은 다음 블록으로 한정시킨다. 
- 블록체인 포크/이중지불 공격이 하에서도 모든 거래들이 다음 블록에 제한되어 타임락되어 있을 것이므로 채굴자들은 멤풀에서 유효한 거래 중 수수료가 높은 거래들만을 선택하여 유효 블록을 채굴해야만 한다. 본질적으로 새로운 수수료를 얻지 못한다.
- 이를 위해 비트코인 코어는 모든 새로운 트랜잭션의 `nLocktime`을 <현재 블록 # + 1>로 설정하고, 모든 입력의 `nSequence`를 0xFFFFFFFE로 설정하여 `nLocktime`을 활성화한다.

<br>

## 조건절을 포함하는 스크립트

- 비트코인 스크립트의 가장 강력한 기능 중 하나는 조건절이라 하는 흐름 제어이다. (`IF...THEN...ELSE` 구문)
- 비트코인 조건부 연산자를 사용하여 논리 조건의 평가 결과에 따라 두 가지 방식으로 잠금 해제되는 상환 스크립트를 구성할 수 있다. 
- 조건식은 무한히 중첩될 수 있기 때문에 비트코인 스크립트 흐름 제어로 무수한 실행 경로가 가능한 매우 복잡한 스크립트를 구성할 수 있따. 중첩은 제한이 없지만, 합의 규칙은 스크립트의 최대 크기(바이트 단위)에 제한을 둔다.
- 비트코인은 IF, ELSE, ENDIF, NOTIF 옵코드를 사용하여 흐름 제어를 구현하며 조건 표현식에는 BOOLAND, BOOLOR, NOT과 같은 부울 연산자가 포함될 수 있다.
- 비트코인 스크립트와 같은 스택 기반 언어에서는 논리 조건이 IF 앞에 위치한다.
  

    ```
    condition
    IF
        code to run when condition is true
    ELSE
        code to run when condition is false
    ENDIF
    code to run in either case
    ```

<br>

### `VERIFY` 옵코드와 조건절 

- 비트코인 스크립트에서 조건의 또 다른 형태는 VERIFY로 끝나는 모든 연산자이다. VERIFY 접미사는 평가된 조건이 TRUE가 아닐 경우 스크립트 실행이 즉시 종료되고 트랜잭션이 유효하지 않은 것으로 간주됨을 의미한다.

- IF 절과 달리, VERIFY 접미사는 전제 조건이 충족되는 경우에만 계속 실행되는 보호절(guard clause) 역할을 한다.

- 예를 들어 `HASH160 <expected hash> EQUALVERIFY <Bob's Pubkey> CHECKSIG` 스크립트에는 밥의 서명과 특정 해시를 생성하는 원상(pre-image, 비밀)이 필요하다. 즉, `<Bob's Sig> <hash pre-image>`와 같은 해제 스크립트를 구성해야 한다. 
- 이 스크립트를 IF 절을 사용해 작성하면 다음과 같다.
    ```
    HASH160 <expected hash> EQUAL
    IF
        <Bob's Pubkey> CHECKSIG
    ENDIF
    ```
- 위 상환 스크립트를 충족하는 해제 스크립트는 동일하게 `<Bob's Sig> <hash pre-image>`이다.

- IF가 포함된 스크립트는 VERIFY 접미사가 붙은 연산 코드를 사용하는 것과 동일한 작업을 수행하며, 둘 다 보호절로 작동한다. 그러나 VERIFY 구조는 더 적은 수의 옵코드를 사용하므로 더 효율적이다.
- 그렇다면 언제 VERIFY를 사용하고 언제 IF를 사용할까? 전제 조건(보호절)을 첨부하기만 하려는 경우라면 VERIFY가 더 좋지만 실행 경로를 두 개 이상 지정하고 싶다면 `IF...ELSE` 흐름 제어절이 필요하다.

<br>

### 스크립트에서 흐름 제어하기

- 일반적으로 각각 다른 방식으로 UTXO를 상환하는 여러 실행 경로를 제공하는 상환 스크립트를 구성하는 것이다.
- 두 서명자 앨리스와 밥 중 한 명만 상환할 수 있는 간단한 예를 살펴보자. (1-of-2)

    ```
    IF
        <Alice's Pubkey> CHECKSIG
    ELSE
        <Bob's Pubkey> CHECKSIG
    ENDIF
    ```
- 위 스크립트의 IF 절 앞에는 조건이 없는데 바로 해제 스크립트가 조건으로 제공되어 앨리스와 밥이 원하는 실행 경로를 선택하게 한다. 
  - 앨리스의 해제 스크립트: `<Alice's Sig> 1`
  - 밥의 해제 스크립트: `<Bob's Sig> 0`
- 앨리스의 해제 스크립트 끝의 1은 IF 절이 첫 번째 경로를 실행하도록 하는 TRUE 조건으로 사용되고 밥의 해제 스크립트 끝의 0은 두 번째 경로를 실행하도록 하는 FALSE 조건으로 사용된다. 
- IF 절은 중첩될 수 있으므로 실행 경로를 더 복잡하게 구성할 수도 있다. 

    ```
    IF
        script A
    ELSE
        IF
            script B
        ELSE
            script C
        ENDIF
    ENDIF
    ```
  - 위 스크립트에는 세 가지 실행 경로(script A, script B, script C)가 있다. 해제 스크립트는 TRUE/FALSE의 시퀀스 형태로 경로를 제공한다.
  - 예를 들어 경로 스크립트 B를 선택하려면 잠금 해제 스크립트가 1 0(TRUE, FALSE)으로 끝나야 한다. (스택에 푸시되므로 두 번째 값이 스택의 맨 위에 오기 때문이다.)
- 이러한 구조로 무수히 많은 실행 경로로 구성된 사용 스크립트를 구축할 수 있으며 각 실행 경로에서 UTXO를 사용하는 서로 다른 방법을 제공할 수 있다. 지출하려면 각 흐름 제어 지점에서 스택에 적절한 TRUE/FALSE 값을 넣어 실행 경로를 탐색하는 해제 스크립트를 구성하면 된다.

<br>

## 복잡한 스크립트의 예

- 두바이에서 수출입 사업을 하는 모하메드의 예를 다시 보자. 모하메드는 유연한 규칙이 있는 회사 자본 계정을 구축하고자 한다. 
  - 타임락에 따라 다양한 수준의 승인이 필요하다.
  - 다중 서명 체계의 참여자는 모하메드, 그의 두 파트너인 사이드와 자이라, 그리고 회사 변호사 압둘이다. 
  - 세 명의 파트너는 다수결 원칙에 따라 결정을 내리기 때문에 세 명 중 두 명이 동의해야 한다. 
  - 그러나 키에 문제가 발생할 경우 변호사가 세 파트너 중 한 명의 서명만 있어도 자금을 회수할 수 있길 원한다. 
  - 마지막으로, 모든 파트너가 한동안 부재중이거나 정상적 생활을 못하는 경우 변호사가 직접 계정을 관리할 수 있길 원한다.
- 위 조건을 위한 상환 스크립트는 다음과 같으며 중첩된 흐름 제어절로 세 가지 실행 경로를 구현한다.
    ```
    01  IF
    02    IF
    03      2
    04    ELSE
    05      <30 days> CHECKSEQUENCEVERIFY `DROP`
    06      <Abdul the Lawyer's Pubkey> CHECKSIGVERIFY
    07      1
    08    ENDIF
    09    <Mohammed's Pubkey> <Saeed's Pubkey> <Zaira's Pubkey> 3 CHECKMULTISIG
    10  ELSE
    11    <90 days> CHECKSEQUENCEVERIFY `DROP`
    12    <Abdul the Lawyer's Pubkey> CHECKSIG
    13  ENDIF
    ```
- 첫 번째 실행 경로 (3번, 9번째 줄)
  - 세 파트너의 2-of-3 다중 서명으로 작동한다. 해제 스크립트 끝에 `TRUE TRUE`를 넣어 이 경로를 선택할 수 있다.
  - 해제 스크립트는 `<Mohammed's Sig> <Zaira's Sig> TRUE TRUE`와 같다.
- 두 번째 실행 경로 (5~7번째 줄)
  - UTXO 생성 후 30일이 경과한 후에만 사용할 수 있다. 이때 변호사 압둘과 세 파트너 중 한 명의 서명이 필요하다. (7번째 줄에서 다중서명의 정족수를 1로 설정)
  - 해제 스크립트는 `0 <Abdul the Lawyer's Sig> <Saeed's Sig> FALSE TRUE`와 같다.
- 세 번째 실행 경로 (11번째 줄)
  - UTXO 생성 후 90일 후 변호사 압둘이 자금을 단독으로 사용할 수 있다. 이 실행 경로를 선택하려면 해제 스크립트가 `FALSE`로 끝나야 한다. 
  - 해제 스크립트는 `<Abdul the Lawyer's Sig> FALSE`와 같다. 

<br>

- 다음 질문에 대해 답을 할 수 있는지 확인해 보자.
  - 변호사가 잠금 해제 스크립트에서 FALSE로 세 번째 실행 경로를 선택하면 언제든 사용할 수 없는 이유는 무엇인가?
  - UTXO가 채굴된 후 각각 5일, 35일, 105일 후에 사용할 수 있는 실행 경로는 몇 개인가?
  - 변호사가 키를 분실하면 자금이 손실되나? 91일이 경과하면 답변이 달라지는가?
  - 파트너는 변호사가 자금에 액세스하지 못하도록 29일 또는 89일마다 시계를 어떻게 "리셋"해야할까?
  - 이 스크립트에서 일부 CHECKSIG 연산 코드에는 VERIFY 접미사가 있는 반면 다른 연산 코드에는 접미사가 없는 이유는 무엇인가?

<br>

## 세그윗 (Segrated Witness)

- 세그윗(분리된 서명, 증인 분리 등으로도 불림.)은 비트코인 합의 규칙과 네트워크 프로토콜의 업그레이드로, 2017년 8월 1일 비트코인 메인넷에서 활성화된 BIP-9 소프트 포크로 제안되고 구현되었다.
- 암호학에서 *증인*(witness)이라는 용어는 암호 퍼즐에 대한 해답을 설명하는 데 사용된다. 비트코인 용어로, 증인은 UTXO에 설정된 조건을 충족하는 것이다. 증인이라는 용어가 unlocking script나 scriptSig 보다 일반적인 용어이다. 
- 세그윗 도입 이전에는 트랜잭션의 모든 입력 뒤에는 트랜잭션의 잠금을 해제하는 증인 데이터가 따라왔다. 세그윗은 단순히 특정 출력의 잠금 스크립트의 해제를 위해 서명을 분리한 것을 의미한다.
- 따라서 세그윗은 증인 데이터를 트랜잭션의 scriptSig 필드에서 별도의 데이터 구조로 이동하는 아키텍처 변경 사항이다. 
- 관련 BIP
  - BIP-141: 세그윗 주요 정의
  - BIP-143: 버전 0 증인 프로그램에 대한 트랜잭션 서명 검증
  - BIP-144: 피어 서비스 - 새로운 네트워크 메시지 및 직렬화 형식
  - BIP-145: (채굴용) 세그윗을 위한 getblocktemplate 업데이트
  - BIP-173: 네이티브 v0-16 증인 출력을 위한 Base32 주소 형식

<br>

### 왜 세그윗인가?

- 세그윗은 비트코인의 확장성, 보안, 경제적 인센티브, 성능에 여러 가지 영향을 미치는 구조적 변화이다.

- **트랜잭션 가변성** (Transaction Malleability) <br>
  트랜잭션 데이터 외부로 증인을 이동하면 식별자로 사용되는 트랜잭션 해시에 더 이상 증인 데이터가 포함되지 않는다. 이를 제거하면 트랜잭션에서 제3자가 수정할 수 있는 트랜잭션 가변성 공격의 기회도 사라진다. 세그윗을 사용하면 트랜잭션 생성자 외에는 트랜잭션 해시를 변경할 수 없으므로 결제 채널, 체인화된 트랜잭션, 라이트닝 네트워크 등 고급 비트코인 트랜잭션 구성에 의존하는 다른 많은 프로토콜의 구현을 크게 개선할 수 있다.
- **스크립트 버전 관리** (Script Versioning)<br>
  세그윗 스크립트가 도입되면서 모든 잠금 스크립트 앞에는 트랜잭션과 블록에 버전 번호가 있는 것과 유사한 스크립트 버전 번호가 붙게 된다. 스크립트 버전 번호가 추가되면 이전 버전과 호환되는 소프트 포크 업그레이드 방식으로 스크립트 언어를 업그레이드하여 새로운 스크립트 피연산자, 구문이나 의미를 도입할 수 있다. 중단 없는 방식으로 스크립팅 언어를 업그레이드하는 것은 비트코인 혁신 속도를 크게 가속화할 수 있다.
- **네트워크 및 스토리지 확장** (Network and Storage Scaling) <br>
  증인 데이터는 트랜잭션의 총 규모에 가장 큰 영향을 미친다. 다중 서명이나 결제 채널에 사용되는 복잡한 스크립트는 바이트 크기가 매우 크다. 어떤 경우에는 이러한 스크립트가 트랜잭션 데이터의 75% 이상을 차지하기도 한다. 따라서 세그윗은 비트코인의 확장성을 개선한다. 노드는 서명 검증 후 증인 데이터를 제거할 수 있고, 간소화된 결제 검증을 수행하는 경우 완전히 무시할 수도 있다. 증인 데이터를 모든 노드에 전송할 필요가 없으며 모든 노드가 디스크에 저장할 필요도 없다.
- **서명 확인 최적화** (Signature Verification Optimization) <br>
  세그윗은 알고리즘의 계산 복잡성을 줄이기 위해 서명 기능(CHECKSIG, CHECKMULTISIG 등)을 업그레이드한다. 세그윗 이전에는 서명을 생성하는 데 사용되는 알고리즘에 트랜잭션 크기에 비례하는 해시 연산이 필요했다. 데이터 해싱 연산은 서명 연산 수에 비례하여 O($n^2$)로 증가하여 서명을 검증하는 모든 노드에 상당한 연산 부담을 주었다. 세그윗을 사용하면 알고리즘이 변경되어 복잡성이 O($n$)으로 감소한다.
- **오프라인 서명 개선** (Offline Signing Improvement) <br>
  세그윗 서명은 서명된 해시에 각 입력이 참조하는 값(금액)을 통합한다. 이전에는 하드웨어 지갑과 같은 오프라인 서명 장치에서 트랜잭션에 서명하기 전에 각 입력값의 금액을 확인해야 했다. 이는 보통 입력으로 참조된 이전 트랜잭션에 대한 대량의 데이터를 스트리밍하여 수행되었다. 이제 금액이 서명된 해시의 일부가 되므로 오프라인 장치에서는 이전 트랜잭션이 필요하지 않다. 금액이 일치하지 않는 경우(손상된 온라인 시스템에 의해 잘못 표시된 경우) 서명은 무효가 될 것이기 때문이다.

<br>

### 세그윗 동작 방식

- 세그윗은 트랜잭션 구성되는 방식의 변경으로 언뜻 트랜잭션 수준의 기능인 것처럼 보이지만 오히려 개별 UTXO가 소비되는 방식을 변경하는 출력별 기능이다.
- 트랜잭션은 세그윗 출력이나 기존 출력을 사용 둘 중 하나를 사용하거나 둘 다 사용할 수 있다. 
- 따라서 트랜잭션을 "세그윗 트랜잭션"이라고 지칭하는 것은 큰 의미가 없고 특정 트랜잭션 출력을 "세그윗 출력"이라고 지칭해야 하는 것이 더 옳다.
- 트랜잭션이 UTXO를 보낼 때는 반드시 트랜잭션이 증인을 제공해야 한다. 세그윗 UTXO는 입력 외부에 분리된 증인 데이터로 만족할 수 있는 잠금 스크립트를 지정한다.

<br>

### 소프트 포크 (이전 버전과의 호환성)

- 세그윗은 출력과 트랜잭션이 설계되는 방식에 중대한 변화이다. 
- 세그윗은 이전 버전과 호환되도록 덜 혼란스러운 변경인 소프트 포크를 통해 도입되었으며, 업그레이드 되지 않은 소프트웨어도 변경 사항을 무시하고 중단 없이 계속 작동하며 여전히 유효성을 검사할 수 있다.
- 다시말해 구형 시스템에서도 빈 서명으로 인해 트랜잭션이 무효화되지는 않으며 대신 업그레이드 된 지갑과 노드가 증인 데이터에서 유효한 증인을 찾을 것으로 기대한다. 

<br>

### 세그윗 출력 및 트랜잭션 예시

- 예시를 통해 세그윗에서 트랜잭션이 어떻게 달라지는지 보자. 
  - P2PKH(Pay-to-Public-Key-Hash)의 변화
  - P2SH(Pay-to-Script-Hash)의 변화 
  - P2SH 스크립트 안 세그윗을 어떻게 삽입하는지

#### Pay-to-Witness-Public-Key-Hash (P2WPKH)

- 앨리스가 밥에게 커피 한 잔 값으로 0.015 BTC를 전송하는 P2PKH 출력은 다음과 같다.
    ```
    DUP HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 EQUALVERIFY CHECKSIG
    ```
- 세그윗을 사용한 P2WPKH(Pay-to-Witness-Public-Key-Hash) 스크립트는 다음과 같다. 
    ```
    0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7
    ```
- 세그윗 출력의 잠금 스크립트는 기존 출력보다 훨씬 간단하다. 
  - 구형 클라이언트에게는 서명이 필요하지 않거나 서명 없이 사용할 수 있는 출력처럼 보일 것이다. 
  - 세그윗 클라이언트에게 첫 번째 숫자(0)는 버전 번호(감시 버전)로 해석되며, 두 번째 부분(20바이트)은 *증인 프로그램*(witness program)이라는 잠금 스크립트에 해당한다. 20바이트의 증인 프로그램은 P2PKH 스크립트에서 처럼 단순 공개키의 해시이다.
- 밥이 이 출력을 소비하기 위한 *세그윗 이전의 트랜잭션*은 다음에서 보는 것처럼 입력 내에 서명을 포함해야 한다. 
    ```
    [...]
    “Vin” : [
    "txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
    "vout": 0,
            "scriptSig": “<Bob’s scriptSig>”,
    ]
    [...]
    ```
- 그러나 *세그윗 트랜잭션*의 입력 부분에 서명이 없다. 대신 트랜잭션 데이터에서 분리된 서명을 포함한다. 
    ```
    [...]
    “Vin” : [
    "txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
    "vout": 0,
            "scriptSig": “”,
    ]
    [...]
    “witness”: “<Bob’s witness data>”
    [...]
    ```
#### P2WPKH의 지갑 구성

- P2WPKH는 수신자에 의해서만 생성될 수 있고, 알려진 공개키, P2PKH 스크립트 또는 주소에서 송신자에 의해 변경될 수 없다.
- P2WPKH 출력은 수신자의 개인키로부터 압축 공개키를 유도해서 생성되어야 한다. 압축되지 않은 공개키는 세그윗의 표준이 아니다. 
- P2WPKH에 사용된 해시가 압축되지 않은 공개키로부터 나온 경우, 자금을 잃을 수 있다. 
- P2WPKH 출력은 수신자가 압축 공개키를 P2WPKH 해시로 전환해서 구성할 수 있다. P2PKH 스크립트, 비트코인 주소, 비압축 공개키를 P2WPKH 증인 스크립트로 전환해서는 안된다. 

#### Pay-to-Witness-Script-Hash (P2WSH)

- 앞의 [Pay-to-Script-Hash (P2SH)](#pay-to-script-hash-p2sh)에서 모하메드 회사에 대한 결제는 다음과 같은 P2SH 잠금 스크립트로 인코딩되었다.
  ```
  HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL
  ```
  - 이 P2SH 스크립트는 자금을 사용하기 위한 2-of-5 다중 서명 요건을 정의하는 상환 스크립트의 해시를 참조하였다.
- 이 출력을 사용하려면 모하메드의 회사는 P2SH 출력의 스크립트 해시와 일치하는 상환 스크립트와 해당 상환 스크립트를 충족하는 서명을 트랜잭션 입력 안에 모두 제시해야 하며 다음과 같다.
    ```
    [...]
    “Vin” : [
    "txid": "abcdef12345...",
    "vout": 0,
        "scriptSig": “<SigA> <SigB> <2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG>”,
    ]
    ```
- 세그윗을 사용한 P2WSH 출력은 다음과 같다. 
  ```
  0 a9b7b38d972cabc7961dbfbcb841ad4508d133c47ba87457b4a0e8aae86dbb89
  ```
- P2WPKH의 예와 마찬가지로 P2WSH 스크립트는 훨씬 간단하며 P2SH 스크립트에서 볼 수 있는 다양한 스크립트 피연산자가 생략되어 있음을 알 수 있다. 즉, 증인 버전(0)과 상환 스크립트의 32바이트 SHA256 해시로 구성된다.
- 이 출력을 소비하기 위한 해제 스크립트는 다음과 같다. 
    ```
    [...]
    “Vin” : [
    "txid": "abcdef12345...",
    "vout": 0,
        "scriptSig": “”,
    ]
    [...]
    “witness”: “<SigA> <SigB> <2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG>”
    [...]
    ```
- 트랜잭션 입력 내에 빈 스크립트 서명이 들어가고, 상환 스크립트와 서명 모두 증인 데이터이 일부로 트랜잭션 데이터 외부로 분리된다. 
  
<br>
  
  > 💡 P2SH와 P2WSH의 해싱 알고리즘
  >
  > P2SH는 20바이트 RIPEMD160(SHA256(script)) 해시를 사용하는 반면, P2WSH 감시 프로그램은 32바이트 SHA256(script) 해시를 사용한다. 이러한 해싱 알고리즘 선택의 차이는 의도적인 것으로 P2WSH에 더 강력한 보안을 제공한다. (P2WSH의 보안 128비트 vs. P2SH의 보안 80비트) 또한 해시의 길이를 사용하여 P2WPKH와 P2WSH를 구분하는데도 사용된다. 

#### P2WPKH와 P2WSH 구분하기

- 두 유형의 증인 프로그램 모두 단일 바이트 버전 번호와 그 뒤에 더 긴 해시로 구성된다.
  - P2WPKH: 서명에 의해 충족되는 공개키 해시
  - P2WSH: 상환 스크립트에 의해 충족되는 스크립트 해시
- 이 둘의 중요한 차이점은 해시의 길이이다.
  - P2WPKH: 20바이트
  - P2WSH: 32바이트
- 이를 통해 지갑은 두 가지 유형의 증인 프로그램을 구별할 수 있다. 

<br>

### 세그윗으로 업그레이드하기

- 먼저 지갑은 특별한 세그윗 유형의 출력을 생성해야 한다. 세그윗 트랜잭션을 구성하는 방법을 알고 있는 지갑에서만 이러한 출력을 사용할 수 있다. 
- 전체 네트워크에서 세그윗은 구 버전과 호환되어 공존한다. 지갑 개발자는 세그윗 기능을 추가하기 위해 지갑 소프트웨어를 독립적으로 업그레이드하여 P2WPKH, P2WSH 결제 유형도 인식할 수 있도록 한다. 한편, 업그레이드 하지 않은 지갑에서는 기존 P2PKH와 P2SH를 계속 사용할 수 있다.
- 이와 관련하여 다음 두 가지 시나리오를 다음 섹션에서 다룬다.
  - 세그윗을 인식하지 못하는 발신자 지갑이 세그윗 트랜잭션을 처리할 수 있는 수신자 지갑으로 결제할 수 있는 기능
  - 세그윗을 인식하는 발신자 지갑이 수신자의 주소로 세그윗을 인식하는지 그렇지 않은지 구분할 수 있는 능력

#### P2SH에 세그윗 포함하기

- 예를 들어, 앨리스의 지갑은 세그윗으로 업그레이드되지 않았지만 밥의 지갑은 업그레이드되어 세그윗 트랜잭션을 처리할 수 있다고 가정해 보자. 
- 앨리스와 밥은 예전의 앨리스와 밥은 세그윗이 아닌 트랜잭션을 사용할 수 있다. 하지만 밥은 세그윗을 사용해 트랜잭션 수수료를 줄이고, 증인 데이터에 적용되는 할인을 받고 싶을 것이다.
- 이 경우 밥의 지갑은 세그윗 스크립트가 포함된 P2SH 주소를 구성할 수 있다. 
- 앨리스의 지갑은 이를 정상적인 P2SH 주소로 인식하고 세그윗에 대한 정보 없이 결제를 진행할 수 있다. 밥의 지갑은 이 자금을 소비하여 세그윗의 장점을 취하고 수수료를 절감할 수 있다.
- 두 가지 형태의 증인 스크립트인 P2WPKH와 P2WSH는 P2SH 주소에 포함될 수 있다. 첫 번째는 P2SH(P2WPKH), 두 번째는 P2SH(P2WSH)로 표기된다.

#### P2SH(P2WPKH)

- 세그윗을 인식하지 못하는 지갑에서 사용할 수 있도록 하는 방법이 Pay-to-Script-Hash 스크립트 내부에 Pay-to-Witness-Public-Key-Hash 증인 프로그램를 포함하는 방법이다. 
- 밥의 지갑은 밥의 공개키로 P2WPKH 증인 프로그램을 구성한다. 그런 다음 이 증인 프로그램을 해시한 결과를 P2SH 스크립트로 인코딩한다. 마지막으로 P2SH 스크립트는 3으로 시작하는 비트코인 주소로 변환된다.
  - 밥이 생성한 P2WPKH 증인 프로그램: 증인 버전(0)과 Bob의 20바이트 공개 키 해시로 구성된다.
      ```
      0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7
      ```
  - 증인 프로그램을 SHA256으로 해시한 후 RIPEMD160 해시하여 20바이트 해시를 생성한다. `bx` 명령어를 사용해 복제하는 명령어는 다음과 같다. 
    ```
    echo \
    '0 [ab68025513c3dbd2f7b92a94e0581f5d50f654e7]'\
    | bx script-encode | bx sha256 | bx ripemd160
    3e0547268b3b19288b3adef9719ec8659f4b2b0b
    ```
  - 상환 스크립트 해시를 비트코인 주소로 변환한다. 
    ```
    echo \
    '3e0547268b3b19288b3adef9719ec8659f4b2b0b' \
    | bx address-encode -v 5
    37Lx99uaGn5avKBxiW26HjedQE3LrDCZru
    ```
- 밥의 고객은 37Lx99uaGn5avKBxiW26HjedQE3LrDCZru로 커피 값을 결제할 수 있다. 
  - 앨리스의 지갑은 P2SH 스크립트로 출력을 잠글 수 있다. 
    ```
    HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL
    ```
- 앨리스의 지갑은 세그윗을 지원하지 않지만, 밥은 앨리스가 생성한 결제를 세그윗 트랜잭션으로 사용할 수 있다.

#### P2SH(P2WSH)

- 마찬가지로 다중서명 스크립트나 기타 복잡한 스크립트를 위한 P2WSH 증인 프로그램을 P2SH 스크립트에 내장할 수 있으므로 모든 지갑이 세그윗과 호환되는 결제를 할 수 있다.
- 모하메드의 회사는 다중서명 스크립트와 함께 세그윗 결제를 사용하는데 지갑이 세그윗용으로 업그레이드 되었는지 여부에 관계없이 모든 고객이 회사에 결제할 수 있도록 모하메드의 지갑은 P2WSH 증인 프로그램을 P2SH 스크립트 안에 포함할 수 있다.
  - 모하메드의 지갑은 상환 스크립트를 SHA256으로 해시한다.
    ```
    echo \
    2 \ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \
    [04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \
    [047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \
    [0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \
    [043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \
    5 CHECKMULTISIG \
    | bx script-encode | bx sha256
    9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73
    ```
  - 해시된 상환 스크립트가 P2WSH 증인 프로그램으로 구성된다.
    ```
    0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73
    ```
  - 증인 프로그램이 SHA256, RIPEMD160 해시되어 기존 P2SH에서 사용되는 것처럼 새로운 20바이트 해시를 생성한다. 
    ```
    echo \
    '0 [9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73]'\
    | bx script-encode | bx sha256 | bx ripemd160
    86762607e8fe87c0c37740cddee880988b9455b2
    ```
  - 지갑은 이 해시로 P2SH 비트코인 주소를 생성한다. 
    ```
    echo \
    '86762607e8fe87c0c37740cddee880988b9455b2'\
    | bx address-encode -v 5
    3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG
    ```
- 이제 모하메드의 고객은 세그윗을 지원할 필요 없이 이 주소(3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG)로 결제할 수 있다. 
- 고객은 모하메드에게 결제를 전송하기 위해 다음 P2SH 스크립트로 출력을 잠근다.
    ```
    HASH160 86762607e8fe87c0c37740cddee880988b9455b2 EQUAL
    ```
- 모하메드 회사는 낮은 거래 수수료 등 세그윗의 이점을 취할 수 있다. 

#### 세그윗 주소

- 세그윗이 활성화된 후에도 대부분의 지갑이 업그레이드될 때까지는 다소 시간이 걸릴 것이다. 처음에는 지갑 간 호환성을 위해 세그윗을 내장한 P2SH 형태로 사용될 될 것이다. 
- 그러나 지갑이 세그윗을 광범위하게 지원하게 되면, P2SH에 포함시키지 않고 세그윗을 위해 설계된 네이티브 주소 형식으로 직접 증인 스크립트를 인코딩하는 것이 좋다.
- 네이티브 세그윗 주소 형식은 [BIP-173: 기본 v0-16 증인 출력을 위한 Base32 주소 형식](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)에 정의되어 있다.
- BIP-173은 증인(P2WPKH 및 P2WSH) 스크립트만 인코딩하며 세그윗이 아닌 P2PKH 또는 P2SH 스크립트와는 호환되지 않는다. 
- BIP-173은 체크섬 처리된 Base32 인코딩이다. (레거시 비트코인 주소의 Base58 인코딩과 비교)
- BIP-173 주소는 "BCH" 오류 감지 알고리즘과 32자 인코딩 세트를 사용함을 암시하는 "beh-ch thirty two"로 발음되는 bech32 주소라고도 한다.
  - BIP-173 주소는 32개의 소문자 전용 영문자와 숫자 문자 집합을 사용하며, 오독이나 오타로 인한 오류를 줄이기 위해 신중하게 선택된다. 이를 통해 읽고 말하기가 더 쉬워지며 QR 코드 인코딩 효율이 45% 더 높아진다.
  - BCH 오류 감지 알고리즘은 이전 Base58Check의 알고리즘에 비해 크게 개선되어 오류를 감지할 뿐만 아니라 오류를 수정할 수도 있다. 텍스트 필드 등의 주소 입력 인터페이스에서 오류를 감지하고 잘못 입력되었을 가능성이 있는 문자를 강조 표시할 수 있다.
- BIP-173 명세에서 bech32 주소의 예는 다음과 같다.
  - 메인넷 P2WPKH: bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4
  - 테스트넷 P2WPKH: tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx
  - 메인넷 P2WSH: bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3
  - 테스트넷 P2WSH: tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7
- 세그윗 bech32 문자열은 최대 90자이며 세 부분으로 구성된다.
  - 사람이 읽을 수 있는 부분: 메인넷 또는 테스트넷을 식별하는 접두사 "bc" 또는 "tb"
  - 구분자: 숫자 "1"은 32자 인코딩 세트에 속하지 않으며 이 위치에서만 구분자로 표시될 수 있다.
  - 데이터 부분: 최소 6개의 영소문자와 숫자 문자. 체크섬 인코딩된 증인 스크립트.

표 3. 비트코인 레거시 및 세그윗 주소

| 유형 | 인코딩 | 접두부  |
| --- | ----| ----|
| Legacy P2PKH Address | Base58 | 1|
| Legacy Testnet P2PKH Address | Base58 | m or n|
| Legacy P2SH Address | Base58 | 3|
| Legacy Testnet P2SH Address | Base58 | 2|
| Nested (embedded) Segwit P2SH(P2WPKH) Address | Base58 | 3|
| Nested (embedded) Segwit P2SH(P2WSH) Address | Base58 | 3|
| Native Segwit P2WPKH Address | Bech32 | bc1|
| Native Segwit Testnet P2WPKH Address | Bech32 | tb1|
| Native Segwit P2WSH Address | Bech32 | bc1|
| Native Segwit Testnet P2WSH Address | Bech32 | tb1|

<br>

> 💡 세그윗 도입
>
> 23년 5월 현재 90% 이상의 세그윗 도입률을 확인할 수 있다. 
> https://charts.woobull.com/bitcoin-segwit-adoption/

<br>

#### 트랜잭션 식별자

- 세그윗은 입력, 출력, 금액의 기본 속성은 변경하지 않고 서명을 교묘하게 수정하여 제3자가 트랜잭션 ID를 변경할 수 있는 트랜잭션의 가변성 문제를 제거한다. 
- 세그윗이 도입되면서 트랜잭션은 txid와 wtxid라는 두 가지 식별자를 갖게 되었다. 
  - txid: 기존 트랜잭션 ID. 증인 데이터가 없는 직렬화된 트랜잭션의 이중 SHA256 해시
  - wtxid: 증인 데이터가 있는 트랜잭션의 새로운 직렬화 형식의 이중 SHA256 해시
- txid는 기존과 동일한 방식으로 계산된다. 트랜잭션의 모든 입력에 scriptSig가 비어있기 때문에 제3자가 수정할 수 있는 트랜잭션 부분이 없다. 따라서, 제3자가 txid를 변경할 수 없다. 
- wtxid는 해시에 증인 데이터가 포함된다는 점에서 확장 ID와 같다. 트랜잭션이 증인 데이터 없이 전송되는 경우 wtxid와 txid는 동일하다. wtxid에는 증인 데이터(서명)가 포함되어 있고 증인 데이터는 가변적일 수 있으므로 트랜잭션이 확인될 때까지는 가변적인 것으로 간주해야 한다는 점에 유의해야한다. 
- 세그윗 입력만 포함된 트랜잭션의 txid만 제3자에 의한 거래 가변성 영향을 받지 않는다.

<br>

### 세그윗의 새로운 서명 알고리즘 

- 세그윗은 네 가지 서명 검증 함수(CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, CHECKMULTISIGVERIFY)의 의미를 수정하여 트랜잭션 약정 해시(commitment hash)가 계산되는 방식을 변경한다.
- 비트코인 트랜잭션의 서명은 트랜잭션 데이터에서 계산된 약정 해시에 적용되며, 서명자의 약정을 나타내는 데이터의 특정 부분을 해당 값을 잠근다. 예를 들어, 간단한 SIGHASH_ALL 유형 서명의 경우, 약정 해시는 모든 입력과 출력을 잠금을 의미한다.
- 안타깝게도 약정 해시 계산 방식은 서명을 검증하는 노드가 상당한 수의 해시 연산을 수행해야 할 가능성을 낳는다. 
- 해시 연산은 트랜잭션의 서명 연산 수에 대해 O($n^2$)로 증가하며 공격자는 매우 많은 서명 연산을 야기하는 트랜잭션을 생성할 수 있다. 
- 세그윗은 약정 해시 계산 방식을 변경하여 이 문제를 해결한다. 
- 세그윗 버전 0 증인 프로그램의 경우, 서명 검증은 BIP-143에 명시된 대로 개선된 약정 해시 알고리즘을 사용한다.
- 새로운 알고리즘의 목표는 다음과 같다.
  - 첫째, 해시 연산 수가 서명 연산 수에 대해 점진적으로 O(n) 만큼 증가하여 지나치게 복잡한 트랜잭션으로 서비스 거부 공격을 일으킬 수 있는 기회를 줄인다.
  - 둘째, 이제 약정 해시에 각 입력값(금액)도 약정의 일부로 포함된다. 하드웨어 지갑과 같은 오프라인 장치의 경우, 통신을 크게 간소화하여 검증을 위해 이전 트랜잭션을 스트리밍할 필요가 없다. 

<br>

### 세그윗의 경제적 동기부여

- 비트코인 마이닝 노드와 풀 노드는 비트코인 네트워크와 블록체인을 지원하는 데 사용되는 리소스에 대한 비용이 발생한다. 비트코인 거래량이 증가함에 따라 리소스(CPU, 네트워크 대역폭, 디스크 공간, 메모리) 비용도 증가한다.

- 비트코인 네트워크에 추가되는 모든 트랜잭션은 노드에서 네 가지 리소스 소비에 영향을 미친다.
  - *디스크 공간* <br>
    모든 트랜잭션은 블록체인에 저장되어 블록체인의 총 크기를 증가시킨다. 블록체인은 디스크에 저장되지만, 오래된 트랜잭션을 "가지치기"(삭제)하여 저장 공간을 최적화할 수 있다.
  - *CPU* <br>
    모든 트랜잭션의 유효성을 검사해야 하므로 CPU 시간이 필요하다.
  - *대역폭* <br>
    모든 트랜잭션은 네트워크를 통해 최소 한 번 이상 전송된다. 블록 전파 프로토콜을 최적화하지 않으면 트랜잭션이 블록의 일부로 다시 전송되어 네트워크 용량에 미치는 영향이 배로 증가한다.
  - *메모리* <br>
    트랜잭션의 유효성을 검사하는 노드는 유효성 검사 속도를 높이기 위해 UTXO 인덱스 또는 전체 UTXO 세트를 메모리에 보관한다. 메모리는 디스크보다 비싸기 때문에, UTXO 세트의 증가는 노드 운영 비용에 더욱 영향을 미친다.

- 트랜잭션에서 비용에 가장 큰 영향을 미치는 부분은 메모리에 추가되는 새로 생성된 출력(UTXO)이다. 이에 비해 서명은 증인 데이터가 한 번만 검증되고 다시는 사용되지 않기 때문에 네트워크와 노드 운영 비용에 가장 적은 부담이다. 노드는 새로운 트랜잭션을 수신하여 증인 데이터를 검증한 직후 해당 증인 데이터를 폐기할 수도 있다. 
- 데이터의 유형을 구분하지 않고 트랜잭션 크기에 따라 수수료를 계산하면 실제 시장의 수수료와 일치하지 않게 된다. 
- 수수료로 인한 인센티브는 지갑 기능에 영향을 미친다. 모든 지갑은 개인정보 보호(주소 재사용 줄이기), 조각화(잔돈 많이 만들기), 수수료 등 여러 요소를 고려한 트랜잭션 수집 전략을 구현해야 한다.
  - 수수료 때문에 지갑이 거래에 가능한 한 적은 수의 입력을 사용하도록 지나치게 동기부여하는 경우, UTXO 선택 및 주소 변경 전략으로 이어져 의도치 않게 UTXO 집합이 증가할 수 있다.
- 입력과 출력의 차이를 고려하여 "Net-new-UTXO"라 부르자. 
  - 입력보다 출력이 많은 Net-new-UTXO가 양수인 트랜잭션은 네트워크와 노드에 부담을 가중한다.
  - 반대로 음수인 트랜잭션은 부담을 줄여준다. 
  - 따라서, 음수 또는 0인 트랜잭션이 장려된다. 
- 세그윗 유무에 따른 트랜잭션 수수료 계산
  - 트랜잭션 A: 3개의 입력, 2개의 출력 트랜잭션 (Net-new-UTXO: -1)
  - 트랜잭션 B: 2개의 입력, 3개의 출력 트랜잭션 (Net-new-UTXO: +1)
  - 두 트랜잭션 모두 2-of-3 다중 서명 스크립트를 사용하여 복잡한 스크립트에서 세그윗이 수수료에 미치는 영향을 비교할 수 있다. 트랜잭션 수수료가 바이트당 30사토시이고, 증인 데이터에 75% 수수료 할인이 적용된다고 가정하자.
  - **세그윗 없이**
    - 트랜잭션 A 수수료: 28,590 사토시
    - 트랜잭션 B 수수료: 20,760 사토시
  - **세그윗으로**
    - 트랜잭션 A 수수료: 12,255 사토시
    - 트랜잭션 B 수수료: 10,425 사토시

- 두 트랜잭션을 비교해보면, 세그윗 여부에 관계없이 Net-new-UTXO가 양수인 트랜잭션 B의 수수료가 더 싸다.
- 세그윗을 사용하면 두 트랜잭션 모두 비용이 상당히 절감된다.
  - UTXO 세트를 줄이기 위해 입력에 드는 비용이 출력에 드는 비용보다 더 저렴해야 하는 반면, 이러한 할인이 더 많은 입력을 사용하지 않도록 UTXO를 생성하려는 요인을 감소시키기도 한다.
- 이러한 배경으로, 세그윗은 비트코인 사용자가 지불하는 수수료에 두 가지 주요 영향을 미친다.
  - 첫째, 세그윗은 증인 데이터를 할인하고 비트코인 블록체인의 용량을 증가시킴으로써 전체 트랜잭션 비용을 절감한다. 
  - 둘째, 세그윗의 증인 데이터 할인은 의도치 않게 UTXO 세트를 부풀릴 수 있는 인센티브의 불균형을 부분적으로 완화한다.
