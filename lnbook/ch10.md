# 10장. 어니언 라우팅 <!-- omit in toc -->

> 📖 원문: [Chapter 10. Onion Routing](https://github.com/lnbook/lnbook/blob/develop/10_onion_routing.asciidoc)

### 목차

- [어니언 라우팅을 설명하는 물리적 예시](#어니언-라우팅을-설명하는-물리적-예시)
  - [경로 선택](#경로-선택)
  - [레이어 만들기](#레이어-만들기)
  - [레이어 벗기기](#레이어-벗기기)
- [HTLC의 어니언 라우팅 소개](#htlc의-어니언-라우팅-소개)
  - [앨리스가 경로를 선택한다.](#앨리스가-경로를-선택한다)
  - [앨리스가 페이로드를 구성한다.](#앨리스가-페이로드를-구성한다)
    - [디나를 위한 최종 노드 페이로드](#디나를-위한-최종-노드-페이로드)
    - [찬을 위한 홉 페이로드](#찬을-위한-홉-페이로드)
    - [밥을 위한 홉 페이로드](#밥을-위한-홉-페이로드)
    - [완료된 홉 페이로드](#완료된-홉-페이로드)
  - [키 생성](#키-생성)
    - [앨리스의 세션 키](#앨리스의-세션-키)
    - [키 생성 세부 사항](#키-생성-세부-사항)
    - [공유 비밀 ss 생성](#공유-비밀-ss-생성)
- [어니언 레이어 감싸기](#어니언-레이어-감싸기)
  - [고정 길이 어니언](#고정-길이-어니언)
  - [어니언 감싸기 (개요)](#어니언-감싸기-개요)
  - [디나의 홉 페이로드 감싸기](#디나의-홉-페이로드-감싸기)
    - [어니언 라우팅 리플레이 방지 및 탐지](#어니언-라우팅-리플레이-방지-및-탐지)
  - [찬의 홉 페이로드 감싸기](#찬의-홉-페이로드-감싸기)
  - [밥의 홉 페이로드 감싸기](#밥의-홉-페이로드-감싸기)
  - [마지막 어니언 패킷](#마지막-어니언-패킷)
- [어니언 보내기](#어니언-보내기)
  - [`update_add_htlc` 메시지](#update_add_htlc-메시지)
  - [앨리스가 밥에게 어니언을 보낸다.](#앨리스가-밥에게-어니언을-보낸다)
  - [밥이 어니언을 검사한다.](#밥이-어니언을-검사한다)
  - [밥이 필러를 생성한다.](#밥이-필러를-생성한다)
  - [밥이 홉 페이로드 난독화를 해제한다.](#밥이-홉-페이로드-난독화를-해제한다)
  - [밥이 다음 홉을 위해 외부 HMAC을 추출한다.](#밥이-다음-홉을-위해-외부-hmac을-추출한다)
  - [밥이 자신의 페이로드를 삭제하고 어니언을 시프트 레프트한다.](#밥이-자신의-페이로드를-삭제하고-어니언을-시프트-레프트한다)
  - [밥이 새로운 어니언 패킷을 구성한다.](#밥이-새로운-어니언-패킷을-구성한다)
  - [밥이 HTLC 상세 내용을 검증한다.](#밥이-htlc-상세-내용을-검증한다)
  - [밥이 찬에게 `update_add_htlc`를 보낸다.](#밥이-찬에게-update_add_htlc를-보낸다)
  - [찬이 어니언을 전달한다.](#찬이-어니언을-전달한다)
  - [디나가 최종 페이로드를 받는다.](#디나가-최종-페이로드를-받는다)
- [에러 반환](#에러-반환)
  - [실패 메시지](#실패-메시지)
  - [결제 중단](#결제-중단)
- [Keysend 자발적 결제](#keysend-자발적-결제)
  - [사용자 지정 어니언 TLV 기록](#사용자-지정-어니언-tlv-기록)
  - [Keysend 결제 보내기 및 받기](#keysend-결제-보내기-및-받기)
  - [라이트닝 애플리케이션의 키센드 및 사용자 지정 기록](#라이트닝-애플리케이션의-키센드-및-사용자-지정-기록)
- [결론](#결론)

---

이 장에서는 라이트닝 네트워크의 어니언 라우팅 메커니즘에 대해 설명한다. 어니언 라우팅의 발명은 라이트닝 네트워크보다 25년이나 앞선 기술이다! 어니언 라우팅은 통신 보안 프로토콜로 미 해군 연구진에 의해 발명되었다. 어니언 라우팅은 연구자, 활동가, 정보 요원, 그 외 모든 사람이 비공개 적으로 그리고 익명으로 인터넷을 사용할 수 있도록 하는 어니언 라우팅 인터넷 오버레이인 Tor에서 가장 유명하게 사용된다.

이 장에서는 라이트닝 프로토콜 아키텍처의 "소스 기반 어니언 라우팅(SPHINX)" 부분에 초점을 맞추고 있으며, 그림 1.에 강조되어 있다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1001.png" width="750">
      그림 1. 라이트닝 프로토콜에서의 어니언 라우팅
  </figure>

<br/>
<br/>

어니언 라우팅은 메시지 발신자가 각 중개 노드에서 최종 수신자에게 가장 안쪽 레이어가 전달될 때까지 연속적으로 중첩된 암호화 레이어를 구축하는 암호화된 통신 방법을 설명한다. '어니언 라우팅'이라는 이름은 양파의 껍질처럼 한 번에 한 층씩 벗겨지는 계층형 암호화를 사용함을 의미한다.

각 중개 노드는 하나의 레이어만 "벗겨낼" 수 있으며 통신 경로에서 다음 단계에 있는 노드를 확인할 수 있다. 어니언 라우팅은 발신자를 제외한 누구도 통신 경로의 목적지나 길이를 알 수 없도록 한다. 각 중개자는 이전 홉과 다음 홉만 알 수 있다.

라이트닝 네트워크는 조지 다네지스와 이안 골드버그가 2009년에 개발한 Sphinx<sup>[[1](#footnote_1)]</sup> 기반의 어니언 라우팅 프로토콜을 구현하여 사용한다.

라이트닝 네트워크에서 어니언 라우팅의 구현은 [BOLT #4: 어니언 라우팅 프로토콜](https://github.com/lightning/bolts/blob/master/04-onion-routing.md)에 정의되어 있다.

<br>

## 어니언 라우팅을 설명하는 물리적 예시 

어니언 라우팅을 설명하는 방법에는 여러 가지가 있지만, 가장 쉬운 방법 중 하나는 물리적으로 봉인된 봉투를 사용하는 것이다. 봉투는 암호화 계층을 나타내며, 지정된 수신자만 봉투를 열어 내용을 읽을 수 있다.

앨리스가 중개자를 통해 간접적으로 디나에게 비밀 편지를 보내고 싶다고 가정해 보자.

<br>

### 경로 선택

라이트닝 네트워크는 발신자만 결제 경로를 선택하고 지정할 수 있는 소스 라우팅(source routing)을 사용한다. 편지가 디나에게 전달되도록 하기 위해 앨리스는 밥과 찬을 중개자로 사용하여 앨리스에서 디나로 가는 경로를 생성한다.

<table>
    <tr>
        <td>팁</td>
        <td>앨리스가 디나에게 도달할 수 있는 경로는 여러 가지일 수 있다. 최적의 경로를 선택하는 과정은 <a href="./ch12.md">12장 경로 찾기 및 결제 전달</a>에서 설명한다. 여기서는 앨리스가 선택한 경로가 밥과 찬을 중개자로 사용하여 디나에게 도달하는 경로라고 가정해 보자.</td>
    </tr> 
</table>

예제를 상기시키기 위해 앨리스가 선택한 경로는 그림 2.와 같다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1002.png" width="750">
      그림 2. 경로: 앨리스 → 밥 → 찬 → 디나
  </figure>

<br/>
<br/>

앨리스가 중개자 밥과 찬에게 정보를 공개하지 않고 이 경로를 어떻게 사용할 수 있는지 살펴보자.

**소스 기반 라우팅(Source-Based Routing)** <br>
소스 기반 라우팅은 인터넷 초창기에 가능했던 방법으로 오늘날 인터넷에서 패킷이 전달되는 일반적 방식은 아니다. 인터넷 라우팅은 각 중개 라우팅 노드에서의 *패킷 스위칭*을 기반으로 한다. 예를 들어, IPv4 패킷에는 발신자와 수신자의 IP 주소가 포함되며, 다른 모든 IP 라우팅 노드는 각 패킷을 목적지로 전달하는 방법을 결정한다. 하지만 모든 중개 노드가 발신자와 수신자를 볼 수 있는 이러한 라우팅 메커니즘에서는 프라이버시가 보장되지 않기 때문에 결제 네트워크에서 사용하기에 적합하지 않다.

<br/>

### 레이어 만들기

앨리스가 디나에게 비밀 편지를 쓰는 것으로 시작한다. 그런 다음 봉투 안에 편지를 봉인하고 겉면에 "To Dina"라고 쓴다.(그림 3.) 봉투는 디나의 공개키로 암호화된 상태이므로 디나만 봉투를 열고 편지를 읽을 수 있다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1003.png" width="400">
      그림 3. 봉투에 봉인된 디나에게 보내는 비밀 편지
  </figure>

<br/>
<br/>

디나의 편지는 **경로** 상 디나 바로 앞에 있는 찬에 의해 디나에게 전달된다. 그래서 앨리스는 찬에게 보내는 봉투 안에 디나에게 보낼 봉투를 넣는다.(그림 4.) 찬이 읽을 수 있는 부분은 목적지인 "To Dina" 뿐이다. 찬의 공개키로 봉투를 암호화하여 찬에게 보내는 봉투 안에 봉인함으로써 찬만 봉투 주소를 읽을 수 있도록 한다. 찬은 여전히 디나의 봉투를 열 수 없다. 그가 볼 수 있는 것은 외부에 적힌 주소 뿐이다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1004.png" width="400">
      그림 4. 디나의 봉인된 봉투가 들어 있는 찬에게 보내는 봉투
  </figure>

<br/>
<br/>

이제 밥이 이 편지를 찬에게 전달할 것이다. 앨리스는 이 편지를 밥에게 보내는 봉투에 넣는다.(그림 5.) 이전과 마찬가지로 봉투는 밥에게 보내는 암호화된 메시지를 나타내며 밥만 읽을 수 있다. 밥은 찬의 봉투 겉면(To Chan)만 읽을 수 있으므로 찬에게 봉투를 보내야 한다는 것을 알 수 있다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1005.png" width="400">
      그림 5. 찬의 봉인된 봉투가 들어 있는 밥에게 보내는 봉투
  </figure>

<br/>
<br/>

엑스레이로 봉투를 들여다볼 수 있다면 그림 6.처럼 봉투가 중첩된 것을 볼 수 있을 것이다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1006.png" width="400">
      그림 6. 중첩된 봉투
  </figure>

<br/>
<br/>

### 레이어 벗기기

이제 앨리스에게 겉면에 "To Bob"이라고 적힌 봉투가 있다. 이는 밥만 해독할 수 있는 암호화된 메시지를 나타낸다. 이제 앨리스는 이 봉투를 밥에게 보내는 절차를 시작한다. 전체 프로세스는 그림 7.과 같다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1007.png" width="550">
      그림 7. 봉투 보내기
  </figure>

<br/>
<br/>

보는 바와 같이 밥은 앨리스로부터 봉투를 받는다. 밥은 이 봉투가 앨리스에게서 온 것임을 알지만 앨리스가 최초에 보낸 사람인지 아니면 봉투를 전달하는 사람인지는 알지 못한다. 밥은 봉투를 열어 "To Chan"이라고 적힌 봉투를 발견한다. 이 편지는 찬에게 전달된 것으로 밥이 이 편지를 열 수는 없다. 밥은 봉투 안에 무엇이 들어 있는지 알지 못하며 찬이 편지를 받는 것인지 다른 봉투를 전달하는 것인지도 모른다. 밥은 찬이 최종 수신자인지 아닌지도 모른다. 밥은 찬에게 봉투를 전달한다.

찬이 밥으로부터 봉투를 받는다. 찬은 앨리스가 보낸 봉투라는 사실을 모른다. 밥이 중개자인지 편지를 보낸 사람인지도 모른다. 찬은 봉투를 열어보니 "To Dina"라고 적힌 또 다른 봉투를 발견하지만 열어볼 수 없다. 찬은 디나가 최종 수신자인지 알지 못한 채 이 편지를 디나에게 전달한다.

디나는 찬으로부터 봉투를 받는다. 봉투를 열어보니 편지가 들어 있고, 이제 디나는 자신이 이 메시지의 최종 수신자임을 알게 된다. 그녀는 중개자 중 누구도 편지의 출처를 알지 못하고 아무도 자신의 비밀 편지를 읽지 않았다는 것을 아는 상태로 편지를 읽는다!

이것이 어니언 라우팅의 핵심이다. 발신자는 메시지를 여러 겹으로 감싸 라우팅 방법을 정확히 지정하고 중개자가 경로나 페이로드에 대한 정보를 얻지 못하도록 한다. 각 중개자는 하나의 레이어를 벗겨내고 전달 주소만 볼 수 있으며 경로의 이전 홉과 다음 홉 외에는 아무것도 알 수 없다.

이제 라이트닝 네트워크에서 어니언 라우팅이 구현된 세부 사항을 살펴보자.

<br>

## HTLC의 어니언 라우팅 소개

라이트닝 네트워크의 어니언 라우팅은 언뜻 복잡해 보이지만 기본 개념을 이해하면 매우 간단하다.

실질적으로 앨리스는 모든 중개 노드에게 경로의 다음 노드와 설정할 HTLC(Hashed Timelock Contract)를 알려준다.

첫 번째 노드(결제 발신자 또는 예시에서 앨리스)를 *시작 노드*(origin node)라 한다. 마지막 노드(결제 수신자 또는 예시에서는 디나)를 *최종 노드*(final node)라 한다.

각 중개 노드(예시에서는 밥과 찬)를 *홉*이라 한다. 모든 홉은 다음 홉으로 *발신 HTLC*(outgoing HTLC)를 설정해야 한다. 앨리스가 각 홉에 전달하는 정보를 *홉 페이로드*(hop payload) 또는 *홉 데이터*(hop data)라고 한다. 앨리스에서 디나로 라우팅되는 메시지를 *어니언*(onion)이라고 하며, 각 홉에 암호화된 홉 페이로드 또는 홉 데이터 메시지로 구성된다.

이제 라이트닝 어니언 라우팅에 사용되는 용어를 알았으니 앨리스의 작업을 다시 설명해 보자. 앨리스는 홉 데이터로 어니언을 구성하여 각 홉에 최종 노드인 디나로 지불을 전송하기 위해 발신 HTLC를 구성하는 방법을 알려주어야 한다.

<br>

### 앨리스가 경로를 선택한다.

[8장](ch08.md)에서 앨리스가 밥과 찬을 통해 디나에게 50,000 사토시를 전송하는 것을 보았다. 이 결제는 그림 8.처럼 일련의 HTLC를 통해 전송된다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1008.png" width="750">
      그림 8. 앨리스에서 디나까지의 HTLC를 사용한 결제 경로
  </figure>

<br/>
<br/>

[11장](./ch11.md)에서 살펴보겠지만, 앨리스가 디나에게 이 경로를 구축할 수 있는 이유는 라이트닝 노드가 라이트닝 가십 프로토콜을 사용해 전체 네트워크에 채널을 알리기 때문이다. 초기 채널 공지 후 밥과 찬은 각각 라우팅 수수료와 지불 라우팅에 대한 타임락 기대치가 포함된 추가 `channel_update` 메시지를 보냈다.

공지와 업데이트를 통해 앨리스는 밥, 찬, 디나 사이의 채널에 대한 다음 정보를 알 수 있다.

- `short_channel_id`: 경로를 구성할 때 앨리스가 채널을 참조하기 위해 사용할 수 있는 각 채널 식별자

- `cltv_expiry_delta`(타임락 델타): 앨리스가 각 HTLC의 만료 시간에 추가할 수 있음.

- `fee_base_msat` 및 `fee_proportional_millionths`: 앨리스가 해당 채널의 릴레이에 대해 해당 노드가 예상하는 총 라우팅 수수료를 계산하는 데 사용할 수 있음.

실제로는 채널이 전송할 최대(`htlc_maximum_msat`) 및 최소(`htlc_minimum_msat`) HTLC 같은 다른 정보도 교환되지만 어니언 경로 구성에 직접 사용되지는 않는다.

이 정보는 그림 9.와 같이 앨리스가 어니언 상세 경로의 노드, 채널, 수수료, 타임락을 식별하는 데 사용된다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1009.png" width="750">
      그림 9. 가십 채널 및 노드 정보로 구성된 상세 경로
  </figure>

<br/>
<br/>

앨리스는 이미 밥과 자신 간의 채널을 알고 있으므로 경로를 구성하는 데 이 정보가 필요하지 않다. 또한 경로의 마지막 채널에 대해 찬의 업데이트가 있기 때문에 앨리스는 디나로부터 채널 업데이트가 필요하지 않기도 하다.

<br/>

### 앨리스가 페이로드를 구성한다.

앨리스가 각 홉에 전달되는 정보에 사용할 수 있는 형식에는 *홉 데이터*라는 기존의 고정 길이 형식과 *홉 페이로드*라는 보다 유연한 TLV(Type-Length-Value) 기반 형식이 있다. TLV 메시지 형식은 프로토콜에 필드를 마음대로 추가할 수 있어 유연성을 제공한다. 두 메시지 형식은 [BOLT #4: 어니언 라우팅 프로토콜, 패킷 구조](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#packet-structure)에 정의되어 있다.

앨리스는 경로의 끝부터 거꾸로, 디나 → 찬 → 밥 순서로 홉 데이터를 구축하기 시작한다. 

#### 디나를 위한 최종 노드 페이로드

앨리스는 먼저 디나에게 전달할 페이로드를 만든다. 디나는 최종 노드이자 결제 수신자이기 때문에 발신 HTLC를 구축하지 않는다. 때문에 디나의 페이로드는 다른 페이로드들과는 다르며(`short_channel_id`에 모두 0을 사용), 어니언의 가장 안쪽 레이어에서 암호화되기 때문에 디나만 이를 알 수 있다. 이것이 바로 [어니언 라우팅을 설명하는 물리적 예시](#어니언-라우팅을-설명하는-물리적-예시)에서 보았던 '디나에게 보내는 비밀 편지'이다.

디나가 받을 홉 페이로드는 디나가 앨리스를 위해 생성한 인보이스 정보와 일치해야 하며, TLV 형식으로 최소한의 필드를 포함해야 한다.

***amt_to_forward*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;밀리사토시 단위의 결제 금액. 여러 부분으로 나누어 결제하는 경우 이 금액은 총액보다 작다. 그렇지 않으면 단일 전액 결제이며 인보이스 금액 및 total_msat 값과 동일하다.

***outgoing_cltv_value*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;결제 만료 타임락은 인보이스에 있는 min_final_cltv_expiry 값으로 설정된다.

***payment_secret*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;인보이스에 포함된 특별한 256비트 비밀 값. 이를 통해 디나는 이 수신된 결제를 인식할 수 있다. 또한 이전에 0값 인보이스를 안전하지 않게 만들었던 일종의 프로빙(probing, 탐색 위험)을 불가능하게 한다. 이 값은 수신자만 복호화할 수 있도록 암호화되므로 중간 노드에 의한 프로빙이 완화되며, 이는 중간 노드가 적법해 보이는 최종 패킷을 재구성할 수 없음을 의미한다.

***total_msat*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;인보이스와 일치하는 총 금액. 한 부분만 있는 경우 생략할 수 있으며, 이 경우 amt_to_forward와 일치하는 것으로 간주되며 인보이스 금액과 같아야 한다.

앨리스가 디나로부터 받은 인보이스에는 금액이 50,000 사토시(50,000,000 밀리사토시)로 명시되어 있다. 디나는 결제의 최소 만기를 min_final_cltv_expiry로 18블록(평균 비트코인 블록을 10분으로 가정할 때 3시간)으로 지정했다. 앨리스가 결제를 시도하는 시점에 비트코인 블록체인이 70만 블록을 기록했다고 가정해 보자. 따라서 앨리스는 outgoing_cltv_value를 최소 블록 높이인 700,018로 설정해야 한다.

앨리스는 디나에 대한 홉 페이로드를 다음과 같이 구성한다.
```
amt_to_forward : 50,000,000
outgoing_cltv_value: 700,018
payment_secret: fb53d94b7b65580f75b98f10...03521bdab6d519143cd521d1b3826
total_msat: 50,000,000
```

그림 10.에 단순화하여 나타낸 것처럼 앨리스는 이를 TLV 형식으로 직렬화한다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1010.png" width="750">
      그림 10. 앨리스가 구성한 디나의 페이로드
  </figure>

<br/>

#### 찬을 위한 홉 페이로드

다음으로 앨리스는 찬을 위해 홉 페이로드를 구성한다. 이렇게 하면 찬이 디나에게 보내는 발신 HTLC를 설정하는 방법을 알 수 있다.

찬을 위한 홉 페이로드에는 short_channel_id, amt_to_forward, outgoing_cltv_value의 세 가지 필드가 포함된다.
```
short_channel_id: 010002010a42be
amt_to_forward: 50,000,000
outgoing_cltv_value: 700,018
```

그림 11.에 단순화하여 나타낸 것처럼 앨리스는 이를 TLV 형식으로 직렬화한다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1011.png" width="750">
      그림 11. 앨리스가 구성한 찬의 페이로드
  </figure>

<br/>

#### 밥을 위한 홉 페이로드

마지막으로 앨리스는 밥을 위한 페이로드를 구성한다. 찬을 위한 홉 페이로드와 동일한 세 개의 필드가 포함되며 값이 다르다.
```
short_channel_id: 000004040a61f0
amt_to_forward: 50,100,000
outgoing_cltv_value: 700,038
```

amt_to_forward 필드 값은 50,100,000 밀리사토시, 즉 50,100 사토시이다. 찬이 디나에게 결제를 라우팅하는 데 100 사토시의 수수료가 발생할 것으로 예상하기 때문이다. 찬이 이 라우팅 수수료를 획득하려면 찬의 수신 HTLC(incoming HTLC)가 찬의 발신 HTLC보다 100 사토시 더 많아야 한다. 찬의 수신 HTLC는 밥의 발신 HTLC이므로, 밥에게 보내는 명령에는 찬이 받는 수수료가 반영된다. 간단히 말해, 밥은 찬에게 50,100 사토시를 보내라고 지시해야 찬이 50,000 사토시를 전송하고 100 사토시를 보유할 수 있다.

마찬가지로 찬은 20블록의 타임락 델타(`cltv_expiry_delta`)를 기대한다. 따라서 찬의 수신 HTLC는 찬의 발신 HTLC보다 20블록 늦게 만료되어야 한다. 이를 위해 앨리스는 밥에게 "찬에게 보내는 HTLC가 찬이 디나에게 보내는 HTLC보다 20블록 늦은 블록 높이인 700,038에서 만료되도록" 지시한다.

<table>
    <td>팁</td>
    <td>채널에 대한 수수료 및 타임락 델타 예상치는 수신 및 발신 HTLC의 차이에 의해 설정된다. 수신 HTLC는 이전 노드에 의해 생성되므로 수수료와 타임락 델타는 해당 이전 노드에 대한 어니언 페이로드에 설정된다. 밥은 찬의 수수료와 타임락 기대치를 충족하는 HTLC를 만드는 방법을 알려준다.</td>
</table>

그림 12.에 단순화하여 나타낸 것처럼 앨리스는 이를 TLV 형식으로 직렬화한다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1012.png" width="750">
      그림 12. 앨리스가 구성한 밥의 페이로드
  </figure>

<br/>

#### 완료된 홉 페이로드

이제 앨리스는 어니언으로 감쌀 세 개의 홉 페이로드를 구축했다. 페이로드의 단순화된 예는 그림 13.과 같다. 

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1013.png" width="750">
      그림 13. 모든 홉에 대한 홉 페이로드
  </figure>

<br/>
<br/>

### 키 생성 

이제 앨리스는 어니언의 다양한 레이어를 암호화하는 데 사용할 여러 개의 키를 생성해야 한다.

이를 통해 앨리스는 높은 수준의 개인정보 보호와 무결성을 달성할 수 있다.

- 앨리스는 어니언의 각 레이어를 암호화하여 의도한 수신자만 읽을 수 있도록 할 수 있다.
- 모든 중개자는 메시지가 수정되지 않았는지 확인할 수 있다.
- 경로에 있는 누구도 누가 이 어니언을 보냈는지, 어디로 가는지 알 수 없다. 앨리스는 발신자인 자신의 신원을, 디나는 송금받는 사람의 신원을 공개하지 않는다.
- 각 홉은 이전 홉과 다음 홉에 대해서만 알게 된다.
- 경로의 길이가 얼마나 되는지, 경로의 어느 지점에 있는지는 아무도 알 수 없다.

아래 나오는 기술적 세부 사항이 어렵다면 다음 섹션으로 건너뛰어도 된다. 다시 돌아와 자세한 내용을 알아보려면 [BOLT #4: 어니언 라우팅, 패킷 구성](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#packet-construction)을 읽길 권한다.

어니언에 사용되는 모든 키의 기반은 앨리스와 밥이 타원 곡선 디피-헬만(ECDH) 알고리즘을 사용하여 독립적으로 생성할 수 있는 공유 비밀(shared secret, ss)이다. ss에서 rho, mu, um, pad라는 4개의 키를 생성할 수 있다.

***rho*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;스트림 암호에서 임의의 바이트 스트림을 생성하는 암호화 보안 의사 난수 생성기(CSPRNG)로 사용된다. 이 바이트는 메시지 본문을 암복호화하고 Sphinx 패킷을 처리하는 과정에서 0바이트를 채우는 데 사용된다.

***mu*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;무결성/진위성 검증을 위해 해시 기반 메시지 인증 코드(HMAC)에 사용된다.

***um*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;오류 보고에 사용된다.

***pad*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;어니언을 고정 길이로 채우기 위한 필러 바이트를 생성하는 데 사용된다.

다양한 키 간의 관계와 키가 생성되는 방식은 그림 14.와 같다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1014.png" width="750">
      그림 14. 어니언 키 생성
  </figure>

<br/>

#### 앨리스의 세션 키

앨리스는 자신의 신원을 노출하지 않기 위해 어니언을 구축할 때 자신의 노드 공개키를 사용하지 않는다. 대신, 앨리스는 세션 개인키라는 임시 32바이트(256비트) 키와 해당 세션의 공개키를 생성한다. 이는 이 어니언에 대해서만 임시 "신원" 및 키 역할을 한다. 이 세션 키에서 앨리스는 이 어니언에 사용될 다른 모든 키를 만든다.

#### 키 생성 세부 사항

[키 생성](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#key-generation), [랜덤 바이트 생성](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#pseudo-random-byte-stream), [임시 키 및 패킷 구성](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#packet-construction)에 사용되는 방식은 BOLT #4의 세 섹션에 명시되어 있다.

너무 전문적인 내용을 다루지 않기 위해 이러한 세부 사항은 책에 포함하지 않았다. 내부 작동 방식을 보려면 위 링크를 참조하길 바란다.

#### 공유 비밀 ss 생성 

거의 마법처럼 보이는 한 가지 중요한 세부 사항은 앨리스가 다른 노드의 공개키만 알면 다른 노드와 공유 비밀을 생성할 수 있다는 것이다. 이는 1970년대에 암호학에 혁명을 일으킨 DH(Diffie-Hellman) 키 교환의 발명에 기반한 것이다. 라이트닝 어니언 라우팅은 비트코인의 secp256k1 곡선에서 타원 곡선 디피-헬만(ECDH)을 사용한다. 자세한 내용은 아래와 같다.

**타원 곡선 디피-헬만 설명** <br>
앨리스의 개인키를 a, 밥의 개인키를 b라고 가정하자. 타원 곡선을 사용하여 앨리스와 밥은 각각 자신의 개인키에 생성점 G를 곱하여 각각 공개키 A와 B를 생성한다.

- *A = aG*
- *B = bG*

이제 앨리스와 밥은 타원 곡선 디피-헬만 키 교환을 사용하여 정보를 교환하지 않고도 둘 다 독립적으로 계산할 수 있는 공유 비밀 ss를 생성할 수 있다.

공유 비밀 ss는 각자의 개인키와 상대방의 공개키를 곱하여 다음과 같이 계산된다.

- *ss = aB = bA*

그런데 여기서 왜 이 두 곱셈의 결과가 같은 값 ss가 될까? 이것이 가능함을 보여주는 수학적 증명은 다음과 같다.

- *ss* 
- *= aB*

앨리스의 개인키 *a*와 밥의 공개키 *B*를 모두 알고있는 앨리스가 계산한 값은 *aB*이다.

- *= a(bG)*

*B = bG*이므로 치환할 수 있다.

- *= (ab)G*

결합법칙에 의해 괄호 위치를 바꿀 수 있다.

- *= (ba)G*

*xy=yx*이므로 (곡선은 아벨군에 있음) *(ab)G = (ba)G*이다.

- *= b(aG)*

결합법칙에 의해 괄호 위치를 바꿀 수 있다.

- *= bA*

*aG = A*이므로 치환할 수 있다.

결과 *bA*는 밥이 *b*(자신의 개인키)와 *A*(앨리스의 공개키)로 독립적으로 계산할 수 있다.

따라서, 다음과 같은 결과가 나타난다.
- ss = aB (앨리스가 계산)
- ss = bA (밥이 계산)

공유 키로 사용할 수 있는 ss를 각각 독립적으로 계산하여 공유 비밀을 전달하지 않고도 두 사람 간에 대칭적으로 비밀을 암호화할 수 있다.

믹스넷(mix-net) 패킷 형식을 갖는 Sphinx의 독특한 특징은 경로의 각 홉마다 별도의 세션 키를 포함시켜 믹스넷 패킷의 크기를 늘리는 대신, 각 홉에서 세션 키를 결정론적으로 무작위화하기 위해 영리한 블라인딩(blinding) 방식을 사용한다는 점이다.

실제로 이 작은 트릭을 사용하면 원하는 보안 속성을 유지하면서 어니언 패킷을 가능한 한 작게 유지할 수 있다.

홉 `i`에 대한 세션 키는 노드 공개키와 홉 `i-1`의 공유 비밀을 사용하여 파생된다.
```
session_key_i = session_key_{i-1} * SHA-256(node_pubkey_{i-1} || shared_secret_{i-1})
```

즉, 이전 홉의 세션 키에 공개키에서 파생된 값과 해당 홉에 대해 파생된 공유 비밀을 곱한다.

타원 곡선 곱셈은 개인키를 몰라도 공개키에 대해 수행할 수 있으므로 각 홉은 결정론적 방식으로 다음 홉의 세션 키를 다시 무작위화할 수 있다.

어니언 패킷의 생성자는 각 홉마다 패킷을 고유하게 암호화했기 때문에 모든 공유 비밀을 알고 있으며, 따라서 모든 블라인딩 요소를 도출할 수 있다.

이러한 지식을 바탕으로 패킷 생성 시, 사용될 모든 세션 키를 미리 도출할 수 있다.

첫 번째 홉은 생성된 원본 세션 키를 사용하며, 이 키는 이후 각 홉에서 세션 키 블라인딩을 시작하는 데 사용된다.

> 💡 믹스 넷 (Mix Networks)
>
> 암호화폐의 아버지 데이비드 차움 박사가 1981년에 전자메일을 익명으로 수신 및 발신하기 위한 목적으로 개발하였다.<sup>[[2](#footnote_2)]</sup> 여러 중개자를 거쳐 목적지에 도달함으로써 인터넷 상에서 추적을 막아주는 대표적인 기술이다. 

<br>

## 어니언 레이어 감싸기

어니언을 감싸는 과정은 [볼트 #4: 어니언 라우팅, 패킷 구성](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#packet-construction)에 자세히 설명되어 있다.

이 섹션에서는 특정 세부 사항을 생략하고 다소 단순화된 수준에서 이 프로세스를 설명한다.

### 고정 길이 어니언

앞서 홉 노드 중 어느 것도 경로의 길이나 경로의 위치를 알지 못한다는 사실을 언급했다. 어떻게 이것이 가능할까?

암호화되어 있더라도 일련의 경로를 가지고 있다면, 경로에서 현재 위치만 보고도 시작점이나 끝점까지 얼마나 남았는지 알 수 없나?

어니언 라우팅에 사용되는 트릭은 모든 노드에서 경로(경로 안내 목록)의 길이를 항상 동일하게 만드는 것이다. 이는 모든 단계에서 어니언 패킷의 길이를 동일하게 유지함으로써 달성할 수 있다.

각 홉에서 어니언 페이로드의 시작 부분에 홉 페이로드가 나타나고, 그 뒤에 19개의 추가 홉 페이로드가 나타난다. 모든 홉은 자신을 20개의 홉 중 첫 번째 홉으로 간주한다.

<table>
    <td>팁</td>
    <td>어니언 페이로드는 1,300바이트이다. 각 홉 페이로드는 65바이트 이하이다.(이보다 작으면 65바이트까지 추가) 따라서 총 어니언 페이로드는 20홉 페이로드에 맞출 수 있다.(1300 = 20 × 65). 따라서 최대 어니언 라우팅 경로는 20홉이다.</td>
</table>

각 레이어가 "벗겨짐"에 따라 어니언 페이로드의 끝에 더 많은 필러 데이터(본질적으로 정크)가 추가되어 다음 홉은 동일한 크기의 어니언을 받게되고 다시 어니언의 "첫 번째 홉"이 된다.

어니언 크기는 1,366바이트이며, 어니언 패킷은 다음과 같이 구조화된다.

***1 byte*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;버전 바이트

***33 bytes*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;앨리스의 신원을 밝히지 않고도 홉별 공유 비밀을 생성할 수 있는 압축된 공개 세션 키

***1,300 bytes*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;각 홉에 대한 지침이 포함된 실제 어니언 페이로드

***32 bytes*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;HMAC 무결성 체크섬

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1015.png" width="750">
      그림 15. 어니언 패킷
  </figure>

<br/>
<br/>

믹스넷 패킷 형식의 독특한 Sphinx 특징은 경로의 각 홉마다 별도의 세션 키를 포함시켜 믹스넷 패킷의 크기를 크게 늘리는 대신, 각 홉에서 세션 키를 결정론적으로 무작위화하기 위해 영리한 블라인딩 방식을 사용한다는 것이다.

실제로 이 사소한 트릭을 사용하면 원하는 보안 속성을 유지하면서 어니언 패킷을 가능한 한 작게 유지할 수 있다.

### 어니언 감싸기 (개요)

다음은 어니언을 감싸는 과정이다. 실제 예시를 통해 각 단계를 살펴보면서 이 목록을 다시 살펴보자.

각 홉마다 발신자(앨리스)는 동일한 프로세스를 반복한다.

1. 앨리스는 홉별 공유 비밀(ss)과 rho, mu, pad 키를 생성한다.
2. 앨리스는 1,300바이트의 필러를 생성하고 이 필러로 1,300바이트의 어니언 페이로드 필드를 채운다.
3. 앨리스는 홉 페이로드에 대한 HMAC을 계산한다. (최종 홉은 0)
4. 앨리스는 홉 페이로드의 길이 + HMAC + 이 길이의 데이터 자체를 저장할 공간을 계산한다.
5. 앨리스는 계산된 공간만큼 어니언 페이로드를 홉 페이로드에 맞게 오른쪽으로 이동한다. 가장 오른쪽의 필러 데이터는 삭제되어 왼쪽에 페이로드를 위한 충분한 공간이 확보된다.
6. 앨리스는 필러를 이동하여 생긴 공간에 길이 + 홉 페이로드 + HMAC를 페이로드 필드 앞쪽에 삽입한다.
7. 앨리스는 rho 키를 사용하여 1,300바이트의 일회성 패드를 생성한다.
8. 앨리스는 rho에서 생성된 바이트와 XOR을 수행하여 전체 어니언 페이로드를 난독화한다.
9. 앨리스는 mu 키를 사용하여 어니언 페이로드의 HMAC을 계산한다.
10. (홉이 공유 비밀을 계산할 수 있도록) 앨리스는 세션 공개키를 추가한다.
11. 앨리스가 버전 번호를 추가한다.
12. 앨리스는 공유 비밀과 이전 홉의 공개키를 해시하여 도출한 값을 사용하여 세션 키를 결정론적으로 다시 블라인드한다.

다음으로 앨리스는 이 과정을 반복한다. 새 키가 계산되고, 어니언 페이로드가 이동되고(더 많은 정크를 삭제), 새 홉 페이로드가 앞에 추가되며, 전체 어니언 페이로드가 다음 홉을 위해 rho 바이트 스트림으로 암호화된다.

최종 홉의 경우, 평문 명령을 통해 3번 과정에 포함된 HMAC은 실제로 모두 0이다. 최종 홉은 이 신호를 사용하여 자신이 실제로 경로의 최종 홉인지를 확인한다. 또는 "다음 홉"을 나타내기 위해 페이로드에 포함된 `short_chan_id`가 모두 0이라는 사실도 사용할 수 있다.

(페이로드를 처리하는 노드의 관점에서의) 각 단계에서 mu 키는 암호화된 어니언 패킷과 단일 암호화 계층이 제거된 패킷의 콘텐츠에 대해 HMAC을 생성하는 데 사용된다. 이 외부 HMAC을 통해 패킷을 처리하는 노드는 어니언 패킷이 수정되지 않았다는 무결성을 확인할 수 있다. 그런 다음 앞서 설명한 "시프트 앤 암호화(shift and encrypt)" 루틴의 반대 과정에서 내부 HMAC이 드러나며, 이는 다음 홉의 외부 HMAC 역할을 한다.

### 디나의 홉 페이로드 감싸기

다시 말해, 어니언은 경로의 끝, 최종 노드 또는 수신자인 디나부터 시작하여 발신자인 앨리스까지 거꾸로 경로가 구축된다.

앨리스는 1,300바이트의 빈 필드, 즉 고정 길이 어니언 페이로드로 시작한다. 그런 다음 패드 키에서 생성된 의사 랜덤(pseudorandom) 바이트 스트림 필러(filler)로 어니언 페이로드를 채운다.(그림 16.)

<table>
    <td>팁</td>
    <td>무작위 바이트 스트림 생성은 암호화 보안 의사 난수 생성기(CSPRNG)인 ChaCha20 알고리즘을 사용한다. 이러한 알고리즘은 초기 시드에서 겉보기에 무작위로 보이는 바이트의 결정론적이고 길며 반복되지 않는 스트림을 생성한다. 자세한 내용은 <a href="https://github.com/lightning/bolts/blob/master/04-onion-routing.md#pseudo-random-byte-stream">BOLT #4: 어니언 라우팅, 의사 랜덤 바이트 스트림</a>에 명시되어 있다.</td>
</table>

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1016.png" width="750">
      그림 16. 어니언 페이로드를 임의의 바이트 스트림으로 채우기
  </figure>

<br/>
<br/>

이제 앨리스는 1,300바이트 배열의 왼쪽에 디나의 홉 페이로드를 삽입하여 필러를 오른쪽으로 이동하고 넘치는 것은 모두 버린다.(그림 17.)

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1017.png" width="750">
      그림 17. 디나의 홉 페이로드 추가
  </figure>

<br/>
<br/>

이를 다른 방식으로 보면 앨리스가 디나의 홉 페이로드 길이를 측정하고 필러를 오른쪽으로 이동하여 어니언 페이로드의 왼쪽에 동일한 공간을 만든 다음 그 공간에 디나의 페이로드를 삽입한 것이다.

아래 줄에서 1,300바이트 어니언 페이로드에 디나의 홉 페이로드가 포함된 다음 필러 바이트 스트림이 나머지 공간을 채우는 결과를 볼 수 있다.

다음으로 앨리스는 전체 어니언 페이로드를 난독화하여 디나만 읽을 수 있도록 한다.

이를 위해 앨리스는 디나도 알고 있는 rho 키를 사용하여 바이트 스트림을 생성한다. 앨리스는 어니언 페이로드의 비트와 rho로 생성된 바이트 스트림에 XOR 연산을 한다. 결과는 1,300바이트 길이의 무작위(또는 암호화된) 바이트 스트림처럼 나타난다.(그림 18.)

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1018.png" width="750">
      그림 18. 어니언 페이로드 난독화
  </figure>

<br/>
<br/>

XOR의 특성 중 하나는 두 번 수행하면 원래 데이터로 돌아간다는 것이다. [밥이 홉 페이로드 난독을 해제한다.](#밥이-홉-페이로드-난독화를-해제한다) 섹션에서 살펴보겠지만, 디나가 rho에서 생성된 바이트 스트림에 동일한 XOR 연산을 적용하면 원래의 어니언 페이로드가 드러나게 된다.

<table>
    <td>팁</td>
    <td>XOR은 자기 동형 함수(involutory function)로, 두 번 적용하면 스스로 취소된다는 의미이다. XOR(XOR(a, b), b) = a. 이 속성은 대칭 키 암호화에서 광범위하게 사용된다.</td>
</table>

앨리스와 디나의 공유 비밀 ss에서 파생된 rho 키는 앨리스와 디나만 가지고 있기 때문에 이 작업은 오직 둘만 할 수 있다. 사실상 이것은 어니언 페이로드를 디나만 볼 수 있도록 암호화한다.

마지막으로 앨리스는 mu 키를 초기화 키로 사용하는 디나의 페이로드에 대한 해시 기반 메시지 인증 코드(HMAC)를 계산한다.(그림 19.)

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1019.png" width="750">
      그림 19. 디나의 홉 페이로드에 HMAC 무결성 체크섬 추가
  </figure>

<br/>

#### 어니언 라우팅 리플레이 방지 및 탐지

HMAC은 보안 체크섬 역할을 하며 디나가 홉 페이로드의 무결성을 검증하는 데 도움을 준다. 32바이트 HMAC은 디나의 홉 페이로드에 추가된다. 평문 데이터가 아닌 암호화된 데이터에 대해 HMAC을 계산한다는 점에 유의하자. 이를 encrypt-then-mac이라고 하며 평문과 암호 텍스트 무결성을 모두 제공하기 때문에 MAC을 사용하는 것이 권장된다.

최신 인증 암호화를 사용하면 연관 데이터(associated data)라고 하는 평문 바이트 집합도 인증할 수 있다.(선택 사항) 실제 일반적으로 이는 평문 패킷 헤더 또는 기타 보조 정보와 같다. 인증할 페이로드에 이 연관 데이터를 포함하면(MAC 인증), MAC 검증자는 이 연관 데이터가 변조되지 않았는지(예: 암호화된 패킷의 평문 헤더를 바꾸는 등) 확인할 수 있다.

라이트닝 네트워크의 맥락에서 이 관련 데이터는 이 체계의 리플레이 방지(replay protection)를 강화하는 데 사용된다. 아래에서 살펴보겠지만, 리플레이 방지는 공격자가 패킷을 네트워크에 재전송하여 경로를 관찰할 수 없도록 한다. 대신 중간 노드는 정의된 리플레이 방지 조치를 사용하여 재전송된 패킷을 감지하고 거부할 수 있다. 기본 Sphinx 패킷 형식은 리플레이를 감지하는 데 사용되는 모든 임시 비밀 키의 로그를 사용한다. 비밀 키가 재사용되면 노드는 이를 감지하고 패킷을 거부할 수 있다.

라이트닝 네트워크에서 HTLC의 특성은 추가적인 경제적 인센티브를 부가하여 리플레이 방지를 더욱 강화할 수 있다. HTLC의 결제 해시는 (완전한 결제를 위해) 한 번만 안전하게 사용할 수 있다는 점을 기억하자. 결제 해시가 다시 사용되어 해당 해시에 대한 결제 비밀을 이미 알고 있는 노드를 통과하면, 해당 노드는 전달 없이 자금을 가져와 전체 결제 금액을 회수할 수 있다! 이 사실을 이용하여 결제 해시를 HMAC 계산에 관련 데이터로 포함하도록 요구함으로써 리플레이 방지를 강화할 수 있다. 이 단계가 추가되면 어니언 패킷을 리플레이하려면 발신자가 동일한 결제 해시를 사용하기로 약속해야 한다. 그 결과, 공격자는 일반적인 리플레이 방지 기능 외에도 리플레이된 HTLC의 전체 양을 잃을 수 있다.

리플레이 방지를 위해 저장되는 세션 키 집합이 계속 늘어날 때 고려해야 할 한 가지 사항은 노드가 이 공간을 확보할 수 있는가 하는 점이다. 라이트닝 네트워크의 맥락에서 대답은 '그렇다'이다! 다시 한 번 말하지만, HTLC 구조의 고유한 특성으로 인해 기본 Sphinx 프로토콜보다 더 개선할 수 있다. HTLC는 절대 블록 높이에 기반한 시간 제한 컨트랙트라는 점을 감안할 때, HTLC가 만료되면 컨트랙트는 사실상 영구적으로 종료된다. 따라서 노드는 리플레이 방지 로그의 항목을 가비지 콜렉션할 안전한 시점을 알 수 있기 때문에 CLTV(CHECKLOCKTIMEVERIFY 연산자) 만료 높이를 지표로 사용할 수 있다. 

### 찬의 홉 페이로드 감싸기

그림 20.에서 찬의 홉 페이로드를 어니언으로 감싸는 단계를 볼 수 있다. 이는 앨리스가 디나의 홉 페이로드를 감싸는 단계와 동일하다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1020.png" width="750">
      그림 20. 찬의 어니언 감싸기
  </figure>

<br/>
<br/>

앨리스는 디나를 위해 생성된 1,300개의 어니언 페이로드로 시작한다. 이 중 처음 65바이트(또는 그 이하)는 난독화된 디나의 페이로드이고 나머지는 필러이다. 앨리스는 디나의 페이로드를 덮어쓰지 않도록 주의해야 한다.

다음으로, 앨리스는 이 홉에서 라우팅 패킷에 추가될 임시 공개키(각 홉의 맨 처음에 생성됨)를 찾아야 한다.

Sphinx는 고유한 임시 공개키(발신자와 중간 노드가 공유 비밀을 생성하기 위해 ECDH 작업에서 사용하는 키)를 포함하지 않고 각 홉에서 결정론적으로 무작위화된 단일 임시 공개키를 사용한다는 것을 기억하자.

패킷을 처리할 때 디나는 공유 비밀과 공개키를 사용하여 블라인딩 값(`b_dina`)을 도출하고, 이를 사용하여 초기 패킷 구성 시 앨리스가 수행하는 것과 동일한 작업으로 임시 공개키를 다시 무작위화한다.

앨리스는 찬의 페이로드에 내부 HMAC 체크섬을 추가하고 이를 어니언 페이로드의 "앞쪽"(왼쪽)에 삽입하여 기존 페이로드를 같은 양만큼 오른쪽으로 이동시킨다. 이 체계에는 사실상 두 개의 HMAC, 즉 외부 HMAC과 내부 HMAC이 사용된다는 점을 기억하자. 이 경우 찬의 내부 HMAC은 실제로 디나의 외부 HMAC이다.

이제 찬의 페이로드는 어니언의 앞쪽에 있다. 찬은 이것을 볼 때 전후에 얼마나 많은 페이로드가 들어왔는지 전혀 알 수 없다. 항상 20홉 중 첫 번째 홉처럼 보인다!

다음으로, 앨리스는 앨리스와 찬의 rho 키에서 생성된 바이트 스트림으로 전체 페이로드를 XOR로 난독화한다. 이 rho 키는 앨리스와 찬만 가지고 있으며, 이들만 어니언을 난독화할 수 있고 난독화 해제하기 위한 바이트 스트림을 생성할 수 있다. 마지막으로, 이전 단계에서 했던 것처럼 찬의 외부 HMAC을 계산하여 암호화된 어니언 패킷의 무결성을 검증하는 데 사용한다.

### 밥의 홉 페이로드 감싸기

그림 21.에서는 밥의 홉 페이로드를 어니언으로 포장하는 데 사용되는 단계를 볼 수 있다.

자, 이제는 쉬워졌다!

찬과 디나의 홉 페이로드가 포함된 어니언 페이로드(난독화)부터 시작하자.

이전 홉에서 생성된 블라인딩 인자로부터 이 홉에 대한 세션 키를 얻는다. 이전 홉의 외부 HMAC을 이 홉의 내부 HMAC으로 포함한다. 밥의 홉 페이로드를 처음에 삽입하고 다른 모든 것을 오른쪽으로 이동하여 끝에서부터 밥의 홉 페이로드 크기의 청크를 떨어뜨린다.(어차피 필러였음)

앨리스와 밥이 공유한 비밀의 rho 키로 전체 XOR을 난독화하여 밥만 풀 수 있도록 한다.

외부 HMAC을 계산하여 밥의 홉 페이로드 끝에 붙인다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1021.png" width="750">
      그림 21. 밥의 어니언 감싸기
  </figure>

<br/>
<br/>

### 마지막 어니언 패킷

최종 어니언 페이로드가 밥에게 전송될 준비가 되었다. 앨리스는 더 이상 홉 페이로드를 추가할 필요가 없다.

앨리스는 어니언 페이로드에 대한 HMAC을 계산하여 밥이 확인할 수 있는 체크섬으로 암호화하여 보호한다.

앨리스는 각 홉에서 공유 비밀과 rho, mu, pad 키를 생성하는 데 사용할 33바이트의 공개 세션 키를 추가한다.

마지막으로 앨리스는 어니언 버전 번호(현재 0)를 앞에 넣는다. 이는 향후 어니언 패킷 형식의 업그레이드를 허용한다.

결과는 그림 22.와 같다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1022.png" width="750">
      그림 22. 어니언 패킷
  </figure>

<br/>
<br>

## 어니언 보내기 

이 섹션에서는 어니언 패킷이 전달되는 방식과 경로를 따라 HTLC가 배포되는 방식을 살펴본다.

### `update_add_htlc` 메시지

어니언 패킷은 `update_add_htlc` 메시지의 일부로 전송된다. 9장 채널 운영 및 결제 전달의 `update_add_htlc`에서 메시지의 내용을 확인할 수 있다.

```
[channel_id:channel_id]
[u64:id]
[u64:amount_msat]
[sha256:payment_hash]
[u32:cltv_expiry]
[1366*byte:onion_routing_packet]
```

이 메시지는 한 채널 파트너가 다른 채널 파트너에게 HTLC를 추가하도록 요청하기 위해 보내는 메시지라는 것을 기억할 것이다. 앨리스가 디나에게 지불한 HTLC를 추가해달라고 밥에게 요청하는 방식이다. 이제 1,366바이트 길이의 마지막 필드인 `onion_routing_packet`의 용도가 이해되었을 것이다. 이것이 바로 우리가 방금 구성한 완전히 감싸진 어니언 패킷이다.

<br>

### 앨리스가 밥에게 어니언을 보낸다.

앨리스가 밥에게 `update_add_htlc` 메시지를 보낸다. 이 메시지에 포함될 내용을 살펴보자.

***channel_id*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;이 필드에는 앨리스와 밥 간 채널 ID(이 예에서는 0000031e192ca1)

***id*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;이 채널에 있는 이 HTLC의 ID(0부터 시작)

***amount_msat*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;HTLC 금액: 50,200,000 밀리사토시

***payment_hash*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;RIPEMD160(SHA-256) 결제 해시: 9e017f6767971ed7cea17f98528d5f5c0ccb2c71

***cltv_expiry*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;HTLC의 만료 타임락은 700,058이 된다. 앨리스는 밥이 협상한 `cltv_expiry_delta`에 따라 밥의 페이로드에 설정된 만료에 20블록을 추가한다.

***onion_routing_packet*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;앨리스가 모든 홉 페이로드로 구성한 최종 어니언 패킷

<br>

### 밥이 어니언을 검사한다.

9장에서 보았듯이, 밥은 약정 트랜잭션에 HTLC를 추가하고 앨리스와 함께 채널의 상태를 업데이트한다.

밥은 앨리스로부터 받은 어니언을 다음과 같이 풀 것이다.

1. 밥은 어니언 패킷에서 세션 키를 가져와 앨리스와 밥의 공유 비밀을 도출한다.
2. 밥은 공유 비밀에서 mu 키를 생성하고 이를 사용하여 어니언 패킷 HMAC 체크섬을 확인한다.

이제 밥은 공유 키를 생성하고 HMAC을 확인했으므로 어니언 패킷 내부의 1,300바이트 어니언 페이로드를 풀 수 있다. 목표는 밥이 자신의 홉 페이로드를 가져온 다음 나머지 어니언을 다음 홉으로 전달하는 것이다.

밥이 자신의 홉 페이로드를 추출하여 제거하면 남은 어니언은 1,300바이트가 아니라 더 짧아진다. 따라서 다음 홉은 자신이 첫 번째 홉이 아니라는 것을 알고 경로가 얼마나 긴지 감지할 수 있다. 이를 방지하기 위해 밥은 어니언을 다시 채우기 위해 필러를 더 추가해야 한다.

<br>

### 밥이 필러를 생성한다.

밥은 앨리스와 약간 다른 방식으로 필러를 생성하지만 일반적인 원리는 동일하다.

먼저 밥은 어니언 페이로드를 1,300바이트 확장하고 0 값으로 채운다. 이제 어니언 패킷의 길이는 2,600바이트이며, 전반부는 앨리스가 전송한 데이터를 포함하고 후반부는 0을 포함한다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1023.png" width="750">
      그림 23. 밥은 어니언 페이로드를 1,300(0으로 채워진) 바이트까지 확장한다.
  </figure>

<br/>
<br/>

이 빈 공간은 밥이 자신의 홉 페이로드를 난독화 해제하는 데 사용하는 것과 동일한 프로세스를 통해 난독화되고 "필러"로 바뀐다. 

<br>

### 밥이 홉 페이로드 난독화를 해제한다.

다음으로 밥은 앨리스와 밥의 공유 키에서 rho 키를 생성한다. 밥은 이 키를 사용해 ChaCha20 알고리즘을 사용해 2,600바이트 스트림을 생성한다.

<table>
    <td>팁</td>
    <td>밥이 생성한 바이트 스트림의 처음 1,300바이트는 앨리스가 rho 키를 사용하여 생성한 바이트 스트림과 정확히 동일하다.</td>
</table>


다음으로 밥은 2,600바이트의 rho 바이트 스트림을 2,600바이트 어니언 페이로드에 비트별 XOR 연산으로 적용한다.

처음 1,300바이트는 앨리스가 적용한 것과 동일한 연산이고 XOR이 필수적이기 때문에 이 XOR 연산에 의해 난독화가 해제된다. 따라서 밥은 자신의 홉 페이로드에 이어 암호화된 것처럼 보이는 일부 데이터를 공개할 것이다.

동시에 어니언 페이로드에 추가된 1,300개의 0에 rho 바이트 스트림을 적용하면 겉보기에는 무작위로 보이는 필러 데이터로 바뀐다.(그림 24.)

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1024.png" width="750">
      그림 24. 밥은 어니언을 난독화 해제하고 필러를 난독화한다.
  </figure>

<br/>
<br/>

### 밥이 다음 홉을 위해 외부 HMAC을 추출한다.

각 홉마다 내부 HMAC이 포함되며, 이는 다음 홉의 외부 HMAC이 된다는 것을 기억하자. 이 경우 밥은 내부 HMAC을 추출하고(이미 외부 HMAC으로 암호화된 패킷의 무결성을 확인했으므로), 이를 난독화된 패킷에 추가하여 찬이 암호화된 패킷의 HMAC을 확인할 수 있도록 하기 위해 따로 보관해 둔다.

### 밥이 자신의 페이로드를 삭제하고 어니언을 시프트 레프트한다.

이제 밥은 어니언의 앞쪽에서 자신의 홉 페이로드를 제거하고 나머지 데이터를 시프트 레프트(shift left)할 수 있다. 이제 후반부 1,300바이트의 필러에서 밥의 홉 페이로드와 동일한 양의 데이터가 어니언 페이로드 공간으로 이동한다.(그림 25.)

이제 밥은 전반부 1,300바이트를 유지하고 확장된 1,300바이트(필러)를 버릴 수 있다.

이제 밥은 다음 홉으로 보낼 1,300바이트의 어니언 패킷을 갖게 되었다. 이 패킷은  마지막 65바이트 정도의 필러가 밥에 의해 추가되었다는 점을 제외하고 앨리스가 찬을 위해 생성한 어니언 페이로드와 거의 동일하다.

<br/>

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_1025.png" width="750">
      그림 25. 밥은 홉 페이로드를 제거하고 나머지는 왼쪽으로 이동하여 새 필러로 간격을 채운다.
  </figure>

<br/>
<br/>

### 밥이 새로운 어니언 패킷을 구성한다.

이제 밥은 어니언 페이로드를 어니언 패킷에 복사하고, 찬을 위한 외부 HMAC을 추가하고, 타원 곡선 곱셈 연산으로 세션 키를 (발신자 앨리스가 하는 것과 같은 방식으로) 다시 무작위화하고, 새 버전 바이트를 추가한다.

세션 키를 다시 무작위화하기 위해 밥은 먼저 자신의 노드 공개키와 자신이 도출한 공유 비밀을 사용하여 자신의 홉에 대한 블라인딩 계수(blinding factor)를 계산한다.

```
b_bob = SHA-256(P_bob || shared_secret_bob)
```

이렇게 생성된 세션 키로 밥은 이제 세션 키와 블라인딩 계수를 사용하여 EC 곱셈을 수행하여 세션 키를 다시 무작위화한다.

```
ession_key_chan = session_key_bob * b_bob
```

그러면 `session_key_chan` 공개키가 어니언 패킷의 앞부분에 추가되어 찬이 처리한다.

<br>

### 밥이 HTLC 상세 내용을 검증한다. 

밥의 홉 페이로드에는 찬을 위한 HTLC를 생성하는 데 필요한 지침이 포함되어 있다.

홉 페이로드에서 밥은 short_channel_id, amt_to_forward, cltv_expiry를 찾는다.

먼저 밥은 해당 short_channel_id를 가진 채널이 있는지 확인한다. 밥은 찬과의 해당 채널이 있다는 것을 발견한다.

다음으로, 밥은 발신 금액(50,100 사토시)이 수신 금액(50,200 사토시)보다 적으므로 밥의 예상 수수료가 충족된다는 것을 확인한다.

마찬가지로, 밥은 발신 cltv_expiry가 수신 cltv_expiry보다 적다는 것을 확인하여 위반이 있을 경우 수신 HTLC를 청구할 수 있는 충분한 시간을 확보한다.

<br>

### 밥이 찬에게 `update_add_htlc`를 보낸다.

밥은 이제 다음과 같은 HTLC를 구성하여 찬에게 보낸다.

***channel_id*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;이 필드에는 밥과 찬 간의 채널 ID(이 예에서는 000004040a61f0)

***id*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;이 채널에 있는 이 HTLC의 ID(0부터 시작)

***amoutn_msat*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;HTLC 금액: 50,100,000 밀리사토시

***payment_hash*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;RIPEMD160(SHA-256) 결제 해시: 9e017f6767971ed7cea17f98528d5f5c0ccb2c71

&nbsp;&nbsp;&nbsp;&nbsp;이는 앨리스의 HTLC 결제 해시와 동일하다.

***cltv_expiry*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;HTLC의 만료 타임락은 700,038이다.

***onion_routing_packet*** <br>
&nbsp;&nbsp;&nbsp;&nbsp;밥이 홉 페이로드를 제거한 후 재구성한 어니언 패킷이다.

<br>

### 찬이 어니언을 전달한다.

찬은 밥과 똑같은 과정을 반복한다.

1. 찬은 `update_add_htlc`를 수신하고 HTLC 요청을 처리하여 약정 트랜잭션에 추가한다.
2. 찬은 앨리스와 찬 간의 공유 키와 mu 서브키를 생성한다.
3. 찬은 어니언 패킷 HMAC을 확인한 다음 1,300바이트 어니언 페이로드를 추출한다.
4. 찬은 어니언 페이로드를 1,300바이트 추가 확장하여 0으로 채운다.
5. 찬은 rho 키를 사용하여 2,600바이트를 생성한다.
6. 찬은 생성된 바이트 스트림을 사용하여 어니언 페이로드를 XOR하고 난독화 해제한다. 동시에 XOR 연산은 여분의 1,300개의 0을 난독화하여 필러로 전환한다.
7. 찬은 페이로드에서 내부 HMAC을 추출하며, 이는 디나의 외부 HMAC이 된다.
8. 찬은 자신의 홉 페이로드를 제거하고 어니언 페이로드를 같은 양만큼 왼쪽으로 이동시킨다. 확장된 1,300바이트에서 생성된 필러 중 일부는 전반부 1,300바이트로 이동하여 어니언 페이로드의 일부가 된다.
9. 찬은 이 어니언 페이로드를 사용하여 디나를 위한 어니언 패킷을 구성한다.
10. 찬은 디나를 위한 update_add_htlc 메시지를 빌드하고 어니언 패킷을 삽입한다.
11. 찬이 디나에게 update_add_htlc를 보낸다.
12. 찬은 이전 홉에서 밥이 디나를 위해 했던 것처럼 세션 키를 다시 무작위화한다.

<br>

### 디나가 최종 페이로드를 받는다.

디나는 찬으로부터 `update_add_htlc` 메시지를 받으면 `payment_hash`를 통해 이것이 자신을 위한 결제라는 것을 알 수 있다. 그녀는 자신이 어니언의 마지막 홉이라는 것을 알고 있다.

디나는 새로운 필러를 구성하지 않고 아무것도 전달하지 않는다는 점을 제외하면 밥과 찬과 똑같은 프로세스를 따라 어니언을 확인하고 포장을 해제한다. 대신 디나는 찬에게 `update_fulfill_htlc`로 응답하여 HTLC를 반환한다. `update_fulfill_htlc`는 앨리스에 도달할 때까지 경로를 따라 역방향으로 흐른다. 모든 HTLC가 상환되고 채널 잔액이 업데이트된다. 결제가 완료되었다!

<br>

## 에러 반환

지금까지 HTLC를 설정하는 어니언의 순방향 전파 과정과 결제가 성공하면 HTLC를 푸는 결제 비밀의 역방향 전파 과정에 대해 살펴보았다.

어니언 라우팅에는 오류 반환(error return)이라는 또 다른 매우 중요한 기능이 있다. 결제, 어니언 혹은 홉에 문제가 있는 경우 오류를 역방향으로 전파하여 모든 노드에 실패를 알리고 모든 HTLC를 풀어야 한다.

오류는 일반적으로 어니언 장애, 노드 장애, 채널 장애의 세 가지 범주로 나뉜다. 이러한 오류는 다시 영구 오류와 일시적 오류로 세분화될 수 있다. 마지막으로, 일부 오류에는 향후 결제 전달 시도에 도움이 되는 채널 업데이트가 포함되어 있다.


오류는 P2P 메시지로 전송되지 않고 어니언 반환 패킷 안에 래핑되어 어니언 경로의 역방향으로 전파된다.


오류 반환은 [BOLT #4: 어니언 라우팅, 오류 반환](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#returning-errors)에 정의되어 있다.

오류를 발견한 반환 노드는 다음과 같이 반환 패킷에 오류 정보를 인코딩한다.

```
    [32*byte:hmac]
    [u16:failure_len]
    [failure_len*byte:failuremsg]
    [u16:pad_len]
    [pad_len*byte:pad]
```

반환 패킷 HMAC 확인 체크섬은 어니언에서 설정한 공유 비밀에서 생성된 um 키로 계산된다.

<table>
    <td>팁</td>
    <td>um 키는 mu를 뒤집은 이름으로, 용도는 같지만 반대 방향(역전파)을 나타낸다.</td>
</table>

다음으로 반환 노드는 ammag 키("gamma"의 반대)를 생성하고, ammag에서 생성된 바이트 스트림으로 XOR 연산을 사용하여 반환 패킷을 난독화한다.

마지막으로 반환 노드는 반환 패킷을 원래 어니언을 수신한 홉으로 보낸다.

오류를 수신한 각 홉은 ammag 키를 생성하고 ammag로부터 생성된 바이트 스트림과 XOR 연산을 사용해 반환 패킷을 다시 난독화한다.

마침내 발신자(시작 노드)가 반환 패킷을 수신한다. 그런 다음 각 홉에 대해 ammag 및 um 키를 생성하고 반환 패킷이 나타날 때까지 반복적으로 반환 오류를 난독화 해제한다.

<br>

### 실패 메시지

실패 메시지는 [BOLT #4: 어니언 라우팅, 실패 메시지](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#failure-messages)에 정의되어 있다.

실패 메시지는 2바이트의 실패 코드와 해당 실패 유형에 해당하는 데이터로 구성된다.

failure_code의 맨 위 바이트는 결합할 수 있는 바이너리 플래그 집합이다.(바이너리 OR 사용)

***0x8000*** (***`BADONION`***) <br>
&nbsp;&nbsp;&nbsp;&nbsp;피어 전송으로 암호화된 해독 불가능한 어니언

***0x4000*** (***`PERM`***) <br>
&nbsp;&nbsp;&nbsp;&nbsp;영구 장애(그렇지 않은 경우 일시적 장애)

***0x2000*** (***`NODE`***) <br>
&nbsp;&nbsp;&nbsp;&nbsp;노드 장애(그렇지 않은 경우 채널)

***0x1000*** (***`UPDATE`***) <br>
&nbsp;&nbsp;&nbsp;&nbsp;새 채널 업데이트 동봉

실패 유형은 현재 [failure_types_table](https://github.com/lnbook/lnbook/blob/develop/failure_types_table.asciidoc)에 정의되어 있다.

<br>

### 결제 중단

현재 라이트닝 네트워크 구현에서는 오류로 인해 결제가 완료되지 않거나 취소되는 등 결제 시도가 중단될 가능성이 있다. 이는 중개 노드의 버그, HTLC를 처리하는 동안 노드가 오프라인 상태가 되거나 악의적인 노드가 오류를 보고하지 않고 HTLC를 보유하는 등의 이유로 발생할 수 있다. 이러한 모든 경우 HTLC는 만료될 때까지 해결될 수 없다. 모든 HTLC에 설정된 타임락(CLTV)은 이 상태를 해결하는 데 도움이 된다.(다른 가능한 HTLC 라우팅 및 채널 장애에도)

그러나 이는 HTLC 발신자가 만료될 때까지 기다려야 함을 의미하며, 해당 HTLC에 커밋된 자금은 HTLC가 만료될 때까지 사용할 수 없는 상태로 유지된다. 또한 발신자는 동일한 결제를 재시도할 수 없으며, 재시도할 경우 원래 결제와 재시도한 결제 모두 실패할 위험이 있으므로 수신자는 두 번 결제를 받게 된다. 발신자는 한 번 전송된 HTLC를 취소할 수 없고 결제가 실패하거나 만료되어야 하기 때문이다. 결제 중단(stuck payments)은 드물지만, 사용자의 지갑에서 결제를 하거나 결제를 취소할 수 없는 원치 않는 사용자 경험을 초래한다.

이 문제를 해결하기 위해 제안된 한 가지 해결책을 중단 없는 결제(stuckless payments)라고 하며, HTLC와는 다른 암호화 기초를 사용하는 (해시 및 비밀 원상 대신 타원 곡선에 포인트를 추가하는 방식) 결제 계약인 PTLC(Point Time-Locked Contracts, 포인트 시간 고정 계약)에 의존한다. PTLC는 ECDSA를 사용하면 번거롭지만, 최근 2021년 11월 활성화가 확정된 비트코인의 탭루트 및 슈노르 서명 기능을 사용하면 훨씬 더 쉽다. 이러한 비트코인 기능이 활성화된 후 라이트닝 네트워크에서 PTLC가 구현될 것으로 예상된다.

<br>

## Keysend 자발적 결제

이 장의 앞부분에서 설명한 결제 흐름에서, 디나가 앨리스로부터 대역 외로 인보이스를 받았거나 프로토콜과 관련이 없는 메커니즘을 통해 인보이스를 받았다고 가정했다.(일반적으로 복사/붙여넣기 또는 QR 코드 스캔) 이 특성은 결제 프로세스가 항상 두 단계로 이루어짐을 의미한다. 첫째 발신자가 인보이스를 받고, 둘째 인보이스에 인코딩된 결제 해시를 사용하여 HTLC를 성공적으로 라우팅하는 것이다. 결제 전 인보이스를 받는 데 필요한 추가 왕복 시간은 라이트닝을 통해 소액 결제를 스트리밍하는 애플리케이션에서 병목점이 될 수 있다. 수신자로부터 인보이스를 먼저 받을 필요 없이 자연스럽게 결제를 '푸시'할 수 있다면 어떨까? `keysend` 프로토콜은 자발적인 푸시 결제를 가능하게 하는 라이트닝 프로토콜의 발신자와 수신자만 알 수 있도록 하는 종단 간 확장이다.

<br>

### 사용자 지정 어니언 TLV 기록

최신 라이트닝 프로토콜은 어니언의 TLV 인코딩을 사용하여 각 노드에 결제를 전달할 위치와 방법을 알려주는 정보를 인코딩한다. TLV 형식을 활용하여 HTLC를 전달할 다음 노드 같은 각 라우팅 정보에 `BigSize` 가변 길이 정수(최대 크기는 64비트 정수)로 인코딩된 특정 유형(또는 키)이 할당된다. 이러한 "필수"(`65536` 이하의 거꾸로된 값) 유형은 나머지 어니언 라우팅 세부 사항과 함께 BOLT #4에 정의되어 있다. 값이 `65536`보다 큰 어니언 유형은 지갑과 애플리케이션에서 "사용자 지정 기록"으로 사용하기 위한 것이다.

사용자 지정 기록을 사용하면 결제 애플리케이션에서 어니언의 키-값 쌍으로 결제에 추가 메타데이터나 컨텍스트를 첨부할 수 있다. 사용자 지정 기록는 다른 모든 홉 콘텐츠와 마찬가지로 어니언 페이로드 자체에 포함되므로 종단 간 암호화가 적용된다. 사용자 지정 기록은 고정 크기 1300바이트 어니언 패킷의 일부를 효과적으로 소비하므로 각 사용자 지정 기록의 각 키와 값을 인코딩하면 나머지 경로를 인코딩하는 데 사용할 수 있는 공간이 줄어든다. 실제로 이는 사용자 지정 기록에 사용되는 어니언 공간이 많을수록 경로가 짧아질 수 있음을 의미한다. 각 HTLC 패킷의 크기가 고정되어 있다는 점을 감안할 때, 사용자 지정 기록은 HTLC에 추가 데이터를 추가하는 것이 아니라 임의의 데이터로 채워졌을 바이트들을 재할당하는 역할을 한다.

<br>

### Keysend 결제 보내기 및 받기

`keysend` 결제는 수신자가 발신자에게 비밀 원상(preimage)을 공개하는 HTLC의 일반적인 흐름을 뒤집는다. 발신자는 수신자에게 보내는 어니언에 원상을 포함하고 HTLC를 수신자에게 라우팅한다. 그러면 수신자는 어니언 페이로드를 복호화하고, 포함된 원상을(HTLC의 결제 해시와 일치해야 함) 사용하여 결제를 정산한다. 그 결과, 원상이 수신자에게 '푸시'되므로 수신자로부터 인보이스를 먼저 받지 않고도 `keysend` 결제를 수행할 수 있다. `keysend` 결제는 TLV 사용자 지정 기록 유형 `5482373484`를 사용하여 32바이트 원상 값을 인코딩한다.

<br>

### 라이트닝 애플리케이션의 키센드 및 사용자 지정 기록

많은 스트리밍 라이트닝 애플리케이션은 `keysend` 프로토콜을 사용하여 네트워크에서 공개키로 식별되는 대상에게 사토시를 지속적으로 스트리밍한다. 일반적으로 애플리케이션에는 `keysend` 기록 외에 팁/기부 메모 또는 기타 애플리케이션 수준 정보와 같은 메타데이터도 포함된다.

<br>

## 결론

라이트닝 네트워크의 어니언 라우팅 프로토콜은 결제 네트워크의 요구 사항을 더 잘 충족하기 위해 Sphinx 프로토콜을 개조한 것이다. 따라서 공개적이고 투명한 비트코인 블록체인에 비해 프라이버시 및 대감시 기능이 크게 개선되었다.

12장에서는 앨리스가 소스 라우팅과 어니언 라우팅의 조합을 사용하여 좋은 경로를 찾고 결제를 디나에게 라우팅하는 방법을 살펴볼 것이다. 경로를 찾기 위해 앨리스는 먼저 11장의 주제인 네트워크 토폴로지에 대해 배워야 한다.

> 💡 대감시(counter-surveillance)
> 
> 역 수색, 전자 역 방책 및 기타 모든 적의 감시를 거부하여 적군이 아군의 부대나 지역을 관측하는 것을 방지하는 데 사용되는 모든 방책 (출처: [네이버 국어사전](https://ko.dict.naver.com/#/search?query=대감시))

<br>

---
<a name="footnote_1">[1]</a> George Danezis and Ian Goldberg, "Sphinx: A Compact and Provably Secure Mix Format," in IEEE Symposium on Security and Privacy (New York: IEEE, 2009), 269–282. 

<a name="footnote_1">[2]</a> David Chaum, “Untraceable electronic mail, return addresses, and digital pseudonyms”, Communications of the ACM, February 1981