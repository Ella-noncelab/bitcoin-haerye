# 7장. 결제 채널 <!-- omit in toc -->

> 📖 원문: [Mastering the Lightning Network 1st Endition - Chapter 07. Payment Channels](https://github.com/lnbook/lnbook/blob/develop/07_payment_channels.asciidoc)

### 목차

- [비트코인 시스템을 사용하는 다른 방법](#비트코인-시스템을-사용하는-다른-방법)
- [비트코인 소유권과 제어](#비트코인-소유권과-제어)
  - [다양한 소유권](#다양한-소유권)
    - [독립 소유권 (단일 개인키를 여러 사람이 공유하는 경우)](#독립-소유권-단일-개인키를-여러-사람이-공유하는-경우)
    - [다중 서명에 의한 소유권 (여러 개인키가 자금을 공동 소유하는 경우)](#다중-서명에-의한-소유권-여러-개인키가-자금을-공동-소유하는-경우)
  - [독립 제어권 없는 공동 소유권](#독립-제어권-없는-공동-소유권)
  - ["잠기거나" 사용할 수 없는 비트코인 방지하기](#잠기거나-사용할-수-없는-비트코인-방지하기)
- [결제 채널 개설하기](#결제-채널-개설하기)
  - [노드의 개인키와 공개키](#노드의-개인키와-공개키)
  - [노드 네트워크 주소](#노드-네트워크-주소)
  - [노드 식별자](#노드-식별자)
  - [노드를 직접 피어로 연결하기](#노드를-직접-피어로-연결하기)
- [채널 구축하기](#채널-구축하기)
  - [채널 관리를 위한 피어 프로토콜](#채널-관리를-위한-피어-프로토콜)
  - [채널 개설 메시지 흐름](#채널-개설-메시지-흐름)
    - [`open_channel` 메시지](#open_channel-메시지)
    - [`accept_channel` 메시지](#accept_channel-메시지)
  - [펀딩 트랜잭션](#펀딩-트랜잭션)
  - [다중 서명 주소 생성하기](#다중-서명-주소-생성하기)
  - [펀딩 트랜잭션 만들기](#펀딩-트랜잭션-만들기)
  - [브로드캐스팅하지 않고 서명된 트랜잭션 가지고 있기](#브로드캐스팅하지-않고-서명된-트랜잭션-가지고-있기)
  - [펀딩 전 환불 정책 만들기](#펀딩-전-환불-정책-만들기)
  - [사전 서명된 환불 거래 만들기](#사전-서명된-환불-거래-만들기)
  - [브로드캐스팅하지 않고 트랜잭션 연결하기](#브로드캐스팅하지-않고-트랜잭션-연결하기)
  - [서명 분리(Segregated Witness)로 거래 가변성 해결](#서명-분리segregated-witness로-거래-가변성-해결)
    - [`funding_created` 메시지](#funding_created-메시지)
    - [`funding_signed` 메시지](#funding_signed-메시지)
  - [펀딩 트랜잭션 브로드캐스팅하기](#펀딩-트랜잭션-브로드캐스팅하기)
    - [`funding_locked` 메시지](#funding_locked-메시지)
- [채널을 통해 결제하기](#채널을-통해-결제하기)
  - [잔액 쪼개기](#잔액-쪼개기)
  - [약정 경쟁](#약정-경쟁)
  - [이전 약정 거래로 부정 행위하기](#이전-약정-거래로-부정-행위하기)
  - [이전 약정 거래 철회](#이전-약정-거래-철회)
  - [비대칭 약정 거래](#비대칭-약정-거래)
  - [지연된 소비 (`to_self`)](#지연된-소비-to_self)
  - [철회 키](#철회-키)
- [약정 트랜잭션](#약정-트랜잭션)
- [채널 상태 변경하기 (Advancing the Channel State)](#채널-상태-변경하기-advancing-the-channel-state)
  - [`commitment_signed` 메시지](#commitment_signed-메시지)
  - [`revoke_and_ack` 메시지](#revoke_and_ack-메시지)
  - [철회와 재약정](#철회와-재약정)
  - [부정 행위와 페널티](#부정-행위와-페널티)
  - [채널 예약금: 페널티에 대한 재정적 부담](#채널-예약금-페널티에-대한-재정적-부담)
- [채널 닫기 (협력적 폐쇄)](#채널-닫기-협력적-폐쇄)
  - [`shutdown` 메시지](#shutdown-메시지)
  - [`closing_signed` 메시지](#closing_signed-메시지)
  - [협력적 폐쇄 트랜잭션](#협력적-폐쇄-트랜잭션)
- [결론](#결론)

---

<br>

이번 장에서는 앨리스(Alice)의 노드가 밥(Bob)의 노드로 채널을 여는 것부터 시작하여 어떻게 결제 채널이 개설되는지 다룬다. 
이를 위해 앨리스와 밥이 교환하는 메시지는 [BOLT #2: 채널 관리를 위한 피어 프로토콜](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md)에 정의된다.
채널 생성 후 앨리스와 밥 노드에서 생성된 트랜잭션은 [BOLT #3: 비트코인 트랜잭션과 스크립트 형식](https://github.com/lightning/bolts/blob/master/03-transactions.md)에 정의된다. 

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0701.png" width="700">
      그림 1. 라이트닝 프로토콜에서 결제 채널: 채널 개설과 폐쇄, 채널 상태 머신 부분을 다룬다.  
  </figure>


## 비트코인 시스템을 사용하는 다른 방법

라이트닝 네트워크는 종종 "레이어 2 비트코인 프로토콜"이라 설명되며 비트코인과 구별되는 것처럼 들린다. 라이트닝의 또 다른 설명은 "비트코인을 더 스마트하게 사용하는 방법" 또는 "비트코인 위에 있는 애플리케이션"이다. 

원래 비트코인 거래는 모든 노드에 전파되고 비트코인 블록체인에 기록됨으로써 유효해진다. 하지만 앞으로 살펴보겠지만, 누군가 2-of-2 다중 서명 출력을 사용하여 해당 비트코인을 독점적으로 사용할 수 있는 트랜잭션을 미리 지정한 경우, 해당 트랜잭션을 브로드캐스팅하지 않은 채 가지고 있는다.

사전 서명된 비트코인 트랜잭션(Presigned Transaction)은 언제든 현금화할 수 있는 만기일이 지난 수표와 같다. 그러나 기존 은행 시스템과 달리 이 거래는 지불에 대한 '약속'(IOU라고도 함.)이 아니라 현금과 동등한, *검증 가능한 무기명 증서*(Bearer Instrument)이다. 거래에 참조된 비트코인이 상환 시점(또는 "현금화"하려는 시점)에 아직 사용되지 않았다면, 비트코인 시스템은 이 사전 서명된 거래가 언제든지 전파되고 기록될 수 있도록 보장한다. 물론 이는 이 거래가 유일한 거래인 경우에만 유효하다. 라이트닝 네트워크 내에서는 동시에 두 개 이상의 사전 서명된 트랜잭션이 존재하는데, 때문에 검증 가능한 무기명 증서의 기능을 유지하려면 보다 정교한 메커니즘이 필요하다. 

라이트닝 네트워크는 비트코인을 사용하는 색다르고 창의적인 방법일 뿐이다. 라이트닝 네트워크에서는 온체인에 기록된 거래와 사전 서명되었지만 보류된 거래(온체인에 제출되지 않은 오프체인 거래)의 조합이 결제 '계층'을 형성하면서 비트코인을 더 빠르고 저렴하며 비공개적으로 사용하는 방법이다. 그림 2.는 라이트닝 결제 채널에서 온체인과 오프체인 비트코인 트랜잭션 간의 관계를 보여준다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0702.png" width="700">
      그림 2. 온체인 오프체인 트랜잭션으로 구성된 라이트닝 결제 채널 <br/>
      라이트닝은 단지 비트코인 시스템을 사용하는 다른 방법일 뿐이다.  
  </figure>

<br>

## 비트코인 소유권과 제어

결제 채널을 이해하기 전에 먼저 비트코인에서 소유권과 제어가 어떻게 작동하는지 이해해야 한다. 

누군가가 비트코인을 "소유하고 있다"는 것은 일반적으로 미사용 거래 출력(Unspent Transaction Outputs, UTXO)이 있는 비트코인 주소의 **개인키를 알고 있다**는 의미이다. 개인키가 있어야 다른 주소로 비트코인을 전송하는 트랜잭션에 서명할 수 있다. 비트코인에서 '소유권'은 해당 비트코인을 사용할 수 있는 능력으로 정의된다.

"Your keys, your coins—not your keys, not your coins."

### 다양한 소유권

개인키 소유권과 비트코인 제어권이 항상 한 사람에게만 있는 것은 아니다.  

#### 독립 소유권 (단일 개인키를 여러 사람이 공유하는 경우)

개인키를 도난 당하거나 원 소유자가 개인키 복사본을 다른 사람에게 주는 등의 이유로 여러 사람이 동일한 개인키를 갖는 경우, 누구라도 다른 사람의 승인 없이 비트코인을 소비할 수 있기 때문에 개인키 소유자 모두가 동일한 소유권을 갖는다. 

#### 다중 서명에 의한 소유권 (여러 개인키가 자금을 공동 소유하는 경우) 

다중 서명 주소는 비트코인 소비를 위해 여러 개의 개인키로 서명해야하는 주소를 말한다. 다중 서명 주소의 소유권은 K-of-N 방식으로 정족수(K)와 총 개인키의 수(N)의 정의에 따라 달라진다. 

예를 들어, 1-of-10 다중 서명 체계에서는 전체 서명자 10명 중 한 명의 서명만 있으면 해당 주소에 잠긴 비트코인을 사용할 수 있다. 이때는 10명이 동일한 키를 소유하여 각자 제어권을 갖는 '독립 소유권' 시나리오와 유사하게 동작한다.

### 독립 제어권 없는 공동 소유권

정족수가 없는 시나리오이다. 라이트닝 네트워크에서 사용되는 것과 같은 2-of-2 방식에서는 서명자 중 어느 누구도 상대방의 서명을 받지 않고는 비트코인을 사용할 수 없다. 이 경우 비트코인 소유자는 누구일까? 누구에게도 제어권이 없기 때문에 실질적인 소유권을 가진 사람은 없다고 봐야한다. 두 서명자는 결정에 대한 투표권과 동등한 지분을 소유하며 결정을 내리기 위해서는 두 당사자 모두 투표해야한다. 비트코인이 되었든 법률 문제가 되었든, 2-of-2 방식의 핵심 문제는 당사자 중 한 명이 부재중이거나 교착 상태가 발생하여 한 당사자가 협조를 거부할 경우 어떻게 되는가하는 것이다.

### "잠기거나" 사용할 수 없는 비트코인 방지하기

2-of-2 다중 서명의 서명자 중 한 명이 서명할 수 없는 상황이거나 의도적으로 서명하지 않을 경우, 자금은 사용할 수 없는 상태가 된다. 이는 실수로 발생할 수 있을 뿐만 아니라(키 분실), 어느 한 쪽에서 협박의 형태로 나타날 수도 있다. ("자금의 일부를 지불하지 않으면 서명하지 않겠다.")

라이트닝 결제 채널은 2-of-2 다중 서명 주소를 기반으로 하며, 두 채널 참여자가 모두 서명자로 참여한다. 현재, 채널은 한 참여자에 의해서만 자금이 조달되며, 채널을 "개설"하기로 선택하면 트랜잭션과 함께 2-of-2 다중 서명 주소에 자금을 입금하게 된다. 해당 트랜잭션이 채굴되고 자금이 다중 서명에 묶이면 이를 사용하기 위해서는 채널 당사자의 서명이 모두 필요하므로 채널 파트너의 협조 없이는 자금을 돌려받을 수 없다.

다음 [결제 채널 개설하기](#결제-채널-개설하기)에서는 자금 손실이나 채널의 두 당사자간 협박 시나리오를 방지하는 공정 프로토콜(fairness protocol)의 구현 방법을 살펴본다. 간단히 말해 채널이 소유한 다중 서명 출력 중 하나를 사전 서명된 트랜잭션(presigned transaction)으로 독점할 수 있는 권한을 부여하는 방식이다.

<br>

## 결제 채널 개설하기

결제 채널은 두 개의 라이트닝 노드 간의 금융 관계로 설명할 수 있으며 이는 두 채널 파트너로부터 2-of-2 다중 서명 주소에 자금을 조달하여 개설된다.

앨리스가 밥의 가게에 직접 연결할 수 있는 결제 채널을 구축하고자 한다 가정해 보자. 먼저 앨리스와 밥의 가게가 운영하는 두 노드가 서로 인터넷 연결을 설정하여 결제 채널의 개설을 협상할 수 있어야 한다.

### 노드의 개인키와 공개키

라이트닝 네트워크의 모든 노드는 노드의 공개키로 식별된다. 공개키는 보통 16진수 인코딩된다. 예를 들어, 르네 픽하트는 현재 다음 노드 공개키로 식별되는 라이트닝 노드(ln.rene-pickhardt.de)를 운영하고 있다.

```
02a1cebfacb2674143b5ad0df3c22c609e935f7bc0ebe801f37b8e9023d45ea7b8
```

각 노드는 처음 초기화할 때 루트 개인키를 생성한다. 개인키는 항상 비공개로 유지되며 노드의 지갑에 안전하게 저장된다. 노드는 이 개인키로 노드 식별자이자 네트워크와 공유하는 공개키를 도출한다. 키 공간이 방대하기 때문에 각 노드가 개인키를 무작위로 생성하는 한 고유한 공개키를 갖게 되며, 따라서 네트워크에서 노드를 고유하게 식별할 수 있다.

### 노드 네트워크 주소

추가로 모든 노드는 다른 노드가 접근할 수 있는 네트워크 주소를 알린다(advertise). 네트워크 주소는 다음 중 하나의 형태이다. 

**TCP/IP** <br>
IPv4 또는 IPv6 주소와 TCP 포트 번호

**TCP/Tor** <br>
Tor "onion" 주소 및 TCP 포트 번호

네트워크 주소 식별자는 웹 등에서 사용되는 네트워크 식별자에 대한 국제 표준과 일치하는 *주소:포트* 형식이다.

예를 들어, 앞에서 노드 공개키 02a1ceb...45ea7b8을 가진 르네의 노드는 현재 네트워크의 TCP/IP 주소로 자신의 노드를 알린다.

```
172.16.235.20:9735
```

  > 💡 라이트닝 네트워크 TCP 포트 
  >
  > 기본 TCP 포트는 9735이지만, 어떤 포트든 선택할 수 있다.

### 노드 식별자

노드 공개키와 네트워크 주소는 @ 기호로 구분된 *노드ID@주소:포트* 형식으로 작성된다.

따라서 르네 노드의 전체 식별자는 다음과 같다.

```
02a1cebfacb2674143b5ad0df3c22c609e935f7bc0ebe801f37b8e9023d45ea7b8
@172.16.235.20:9735
```

이 식별자는 QR 코드로 인코딩되기도 해서 특정 노드에 자신의 노드를 연결하려는 경우 이를 스캔하여 쉽게 연결할 수도 있다.

비트코인 노드와 마찬가지로 라이트닝 노드는 노드 공개키와 네트워크 주소를 "가십(gossip)"함으로써 라이트닝 네트워크에서 자신의 존재를 알린다. 이렇게 함으로써 다른 노드가 해당 노드를 찾아 연결할 수 있는 모든 알려진 노드의 인벤토리(데이터베이스)를 보관하고 라이트닝 P2P 메시지 프로토콜에 정의된 메시지를 교환할 수 있다.

  > 💡 가십(gossip) 프로토콜
  >
  > 분산 환경에서 메시지를 전달하는 방식의 하나이다. 소문이 빠르게 퍼져나가는 모습과 유사한 형태를 가지고 있어 붙여진 이름이다.  

### 노드를 직접 피어로 연결하기

채널을 열기 위해서는 먼저 직접 피어를 맺어야 한다.

앨리스의 노드가 밥의 노드에 연결하려면 밥의 노드 공개키 또는 공개키가 포함된 전체 주소(IP 또는 Tor 주소와 포트)가 필요하다. 밥은 가게를 운영하므로 밥의 노드 주소 공개되어 있다고 할 때(웹의 인보이스 또는 스토어 결제 페이지에서 검색 등) 앨리스는 밥의 주소가 포함된 QR 코드를 스캔하여 자신의 노드가 밥의 노드에 연결하도록 할 수 있다.

앨리스의 노드가 밥의 노드와 연결되면 두 노드는 이제 직접 연결된 피어가 된 것이다.

<br>

## 채널 구축하기

이제 앨리스와 밥의 라이트닝 노드가 연결되었으니 결제 채널을 구축하는 과정을 시작할 수 있다. 이 섹션에서는 채널 관리를 위한 라이트닝 피어 프로토콜로 알려진 두 노드 간의 통신과 비트코인 트랜잭션을 구축하는 데 사용하는 암호화 프로토콜을 살펴본다.

이 시나리오에서는 두 가지 프로토콜을 설명한다. 먼저 메시지 프로토콜인데 이는 라이트닝 노드가 인터넷을 통해 통신하는 방법과 서로 주고받는 메시지를 설명한다. 두번째는 두 노드가 비트코인 트랜잭션을 구성하고 서명하는 방법을 설정하는 암호화 프로토콜이다.


### 채널 관리를 위한 피어 프로토콜

채널 관리를 위한 라이트닝 피어 프로토콜은 [BOLT #2: 채널 관리를 위한 피어 프로토콜](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md)에 정의된다. 이 장에서는 BOLT #2의 **채널 개설** 및 **채널 폐쇄**를 자세히 다룬다.

### 채널 개설 메시지 흐름

채널 개설은 앨리스와 밥의 노드 간에 6개의 메시지(각 피어에서 3개 씩)를 주고받음으로써 이루어진다. 
`open_channel, accept_channel, funding_created, funding_signed, funding_locked, funding_locked` 

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0703.png" width="600">
      그림 3. 채널 개설 메시지 흐름
  </figure>

<br/>
<br/>
그림 3.에서 앨리스와 밥의 노드는 다이어그램의 양쪽에 있는 세로선 "A"와 "B"로 표시된다. 이와 같은 시간 순서 다이어그램은 아래쪽으로 흐르는 시간과 두 피어 사이에서 한 쪽에서 다른 쪽으로 흐르는 메시지를 나타낸다. 선은 각 메시지를 전송하는 데 필요한 경과 시간을 나타내기 위해 아래로 기울어져 있으며, 메시지의 방향이 화살표로 표시되어 있다.

채널 개설은 세 부분으로 이루어진다. 

먼저, 두 피어는 서로의 용량(Capacity)과 기대치를 전달하며, 앨리스는 `open_channel`을 통해 요청을 시작하고 밥은 `accept_channel`을 통해 채널 요청을 수락한다.

둘째, 앨리스는 펀딩 및 환불 트랜잭션을 구성하고(이 섹션의 뒷부분에서 살펴보기로 함) `funding_created`를 밥에게 보낸다. "환불(Refund)" 트랜잭션의 다른 이름은 **"약정(Commitment)" 트랜잭션**으로, 채널의 현재 잔액 분배를 약속하기 때문이다. 밥은 필요한 서명을 `funding_signed`와 함께 다시 전송하여 응답한다. 이러한 상호작용은 채널을 보호하고 도난을 방지하기 위한 암호화 프로토콜의 기반이 된다. 이제 앨리스가 펀딩 트랜잭션을 온체인에 브로드캐스팅하여 결제 채널을 개설하고 고정(anchoring)한다. 제출된 트랜잭션은 비트코인 블록체인에서 승인되어야 한다.

트랜잭션이 충분한 수(`accept_channel` 메시지의 `minimum_depth`)의 승인(confirmation)을 받으면 앨리스와 밥은 `funding_locked` 메시지를 교환하고 채널은 정상 작동 모드로 전환된다.

 > 💡 `funding_signed`
 > 
 > `funding_signed` 이라는 이름이 약간 혼란스러울 수 있는데 이 메시지에는 펀딩 트랜잭션에 대한 서명이 아니라 앨리스가 다중 서명 주소에 잠긴 비트코인을 돌려받을 수 있도록 하는 **환불 트랜잭션에 대한 밥의 서명**이 포함되어 있다. 

#### `open_channel` 메시지

앨리스의 노드는 밥의 노드에 `open_channel` 메시지를 전송하여 결제 채널을 요청한다. 이 메시지에는 채널 개설에 대한 앨리스의 기대치 정보가 포함되어 있으며, 밥은 이를 수락하거나 거부할 수 있다.

<br>

`open_channel` 메시지
```
[chain_hash:chain_hash]
[32*byte:temporary_channel_id]
[u64:funding_satoshis]
[u64:push_msat]
[u64:dust_limit_satoshis]
[u64:max_htlc_value_in_flight_msat]
[u64:channel_reserve_satoshis]
[u64:htlc_minimum_msat]
[u32:feerate_per_kw]
[u16:to_self_delay]
[u16:max_accepted_htlcs]
[point:funding_pubkey]
[point:revocation_basepoint]
[point:payment_basepoint]
[point:delayed_payment_basepoint]
[point:htlc_basepoint]
[point:first_per_commitment_point]
[byte:channel_flags]
[open_channel_tlvs:tlvs]
```

이 메시지에 포함된 필드는 앨리스가 원하는 채널 매개변수와 채널 운영에 대한 보안 기대치를 반영하는 앨리스 노드의 다양한 구성 설정을 지정한다.

아래는 메시지의 일부 필드에 대한 설명이다. 이 외의 필드와 라이트닝 피어 프로토콜 메시지를 이해하려면 BOLT 사양에서 찾아보기 바란다. 

***chain_hash*** <br>
이 채널에 사용할 블록체인(예: 비트코인 메인넷)을 식별한다. 일반적으로 해당 블록체인 제네시스 블록의 해시이다.

***funding_satoshis*** <br>
앨리스가 채널에 펀딩하는 데 사용할 금액으로, 총 채널 용량(channel capacity)이다.

***channel_reserve_satoshis*** <br>
채널의 양쪽에 예치되어 있는 사토시 단위의 최소 잔액이다. 페널티에 대해 이야기할 때 다시 설명한다.

***push_msat*** <br>
앨리스가 채널 펀딩 시 즉시 밥에게 지불금으로 "푸시"하는 선택적 금액이다. 이 값을 0이 아닌 다른 값으로 설정하면 사실상 채널 파트너에게 돈을 선물하는 것이 되므로 주의해서 사용해야 한다.

***to_self_delay*** <br>
프로토콜의 매우 중요한 보안 매개변수이다. `open_channel` 메시지의 값은 응답자의 트랜잭션(commitment transaction)에, `accept_channel`은 채널 개설 요청자의 트랜잭션에 사용된다. 이러한 비대칭성은 상대방이 일방적으로 자금을 청구하기 위해 얼마나 기다려야 하는지 표현할 수 있도록 하기 위해 존재한다. 밥이 앨리스의 의사에 반해 일방적으로 채널을 닫는 경우, 밥은 여기에 정의된 지연 시간 동안 자신의 자금에 액세스하지 못하는 것에 약속한다. 이 값이 높을수록 앨리스는 더 높은 보안을 확보하는 것이고 밥의 자금은 더 오래 잠겨 있을 수 있다.

***funding_pubkey*** <br>
이 채널을 고정하는 2-of-2 다중 서명에 사용할 앨리스의 공개키이다.

***X_basepoint*** <br>
약정(commitment), 철회(revocation), 라우팅된 결제(HTLCs), 폐쇄 트랜잭션(closing transactions) 등 다양한 부분에서 자식키를 도출하는 데 사용되는 마스터 키이다. 다음 장에서 이 키들의 사용법과 설명을 다룬다.

#### `accept_channel` 메시지

앨리스의 `open_channel` 메시지에 대한 응답으로 밥은 `accept_channel` 메시지를 보낸다. 

<br>

`accept_channel` 메시지
```
[32*byte:temporary_channel_id]
[u64:dust_limit_satoshis]
[u64:max_htlc_value_in_flight_msat]
[u64:channel_reserve_satoshis]
[u64:htlc_minimum_msat]
[u32:minimum_depth]
[u16:to_self_delay]
[u16:max_accepted_htlcs]
[point:funding_pubkey]
[point:revocation_basepoint]
[point:payment_basepoint]
[point:delayed_payment_basepoint]
[point:htlc_basepoint]
[point:first_per_commitment_point]
[accept_channel_tlvs:tlvs]
```

`open_channel` 메시지와 유사하며 밥의 노드 기대치 및 구성 값이 포함되어 있다.

앨리스가 결제 채널을 구성하는 데 사용할 `accept_channel`의 가장 중요한 두 필드는 다음과 같다.

***funding_pubkey*** <br>
밥의 노드가 채널을 고정하는 2-of-2 다중 서명 주소에 사용할 밥의 공개키이다.

***minimum_depth*** <br>
밥의 노드가 채널이 열렸고 사용할 준비가 된 것으로 판단하기 전 기대하는  펀딩 트랜잭션의 승인(confirmation) 횟수이다.


### 펀딩 트랜잭션

앨리스의 노드가 밥의 `accept_channel` 메시지를 수신하면, 채널을 비트코인 블록체인에 고정하는 자금 조달 트랜잭션을 구성하는 데 필요한 정보를 얻게 된다. 이전 장에서 설명한 것처럼, 라이트닝 결제 채널은 2-of-2 다중 서명 주소로 고정된다. 먼저, 펀딩 트랜잭션(그리고 이후에 설명하는 환불 트랜잭션)을 구성할 수 있도록 다중 서명 주소를 생성해야 한다.

### 다중 서명 주소 생성하기

펀딩 트랜잭션은 앨리스와 밥의 `funding_pubkey` 공개키로 구성된 2-of-2 다중 서명 출력으로 일정량의 비트코인(`open_channel` 메시지의 `funding_satoshis`)을 전송한다.

앨리스의 노드는 아래와 같이 다중 서명 스크립트를 구성한다.

```
2 <Alice_funding_pubkey> <Bob_funding_pubkey> 2 CHECKMULTISIG
```

실제로 펀딩 키는 증인 스크립트에 배치되기 전에 결정론적으로 정렬된다(직렬화된 압축 공개키를 사전적 순서로 정렬함). 이 정렬 순서에 미리 동의함으로써 양 당사자가 동일한 펀딩 트랜잭션 출력을 구성하고, 교환된 약정 트랜잭션 서명에 의해 서명되도록 보장한다.

이 스크립트는 P2WSH(Pay-to-Witness-Script-Hash) 비트코인 주소로 인코딩되며, 인코딩 결과는 다음과 같다.

```
bc1q89ju02heg32yrqdrnqghe6132wek25p6sv6e564znvrvez7tq5zqt4dn02
```

### 펀딩 트랜잭션 만들기

이제 앨리스의 노드는 펀딩 트랜잭션을 생성하여 밥과 합의한 금액(`funding_satoshis`)을 2-of-2 다중 서명 주소로 전송할 수 있다. `funding_satoshis`가 140,000이고 앨리스가 200,000 사토시 출력을 소비하고 60,000 사토시 거스름돈이 생성된다고 가정해 보자. 앨리스의 펀딩 트랜잭션은 아래와 유사하다. 

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0704.png" width="700">
      그림 4. 앨리스가 펀딩 트랜잭션을 만든다. 
  </figure>

<br/>
<br/>
앨리스는 이 트랜잭션을 브로드캐스팅하지 않는다. 2-of-2 다중 서명 주소에 일단 송금하면 밥의 서명 없이 앨리스가 돈을 회수할 수 있는 방법이 없기 때문에 이대로 브로드캐스팅하면 14만 사토시가 위험에 처할 수 있다.

**이중 자금(Dual-Funded) 결제 채널** <br>
현재 라이트닝 구현에서는 채널 개설을 시작하는 노드에 의해서만(예시에서는 앨리스) 자금이 조달된다. 이중 자금 채널이 제안되었지만 아직 구현되지는 않았다.(*수락된 제안들*) 이중 펀딩 채널에서는 앨리스와 밥이 모두 펀딩 트랜잭션에 입력(inputs)을 기여하게 된다. 이중 자금 채널에서 메시지 흐름과 암호화 프로토콜이 조금 더 복잡하기 때문에 아직 구현되지는 않았지만, 향후 라이트닝 BOLT 업데이트에 포함될 예정이다. c-lightning 구현체에는 이중 펀딩 채널에 대한 실험적인 버전의 변형이 포함되어 있다.

  > 💡 수락된 제안들(Accepted Proposals)
  > 
  > [링크](https://github.com/lightning/bolts/wiki/Lightning-Specification-1.1-Proposal-States)에서 BOLT 명세의 수락된 제안들을 확인할 수 있다. 이 목록에서 '이중 자금 결제 채널'도 확인할 수 있다.

  > 💡 c-lightning 노드
  >
  > 블록스트림(Blockstream)에서 만든 라이트닝 노드 구현체이다. 최근 Core Lightning(CLN)으로 명칭을 바꾸었다.

### 브로드캐스팅하지 않고 서명된 트랜잭션 가지고 있기

라이트닝을 가능하게 하는 중요한 비트코인 기능은 트랜잭션을 구성하고 서명할 수는 있지만, 브로드캐스팅하지 않는 다는 점이다. 유효한 트랜잭션이더라도 블록체인에 전파되고 승인되기 전까지는 인식되지 않으며, 블록체인에 없는 거래이기 때문에 출력(outputs)을 사용할 수도 없다. 라이트닝 네트워크에서는 이 기능을 여러 번 사용하며, 앨리스의 노드는 펀딩 트랜잭션을 구성할 때도 브로드캐스팅하지 않고 가지고 있는다. 

### 펀딩 전 환불 정책 만들기

앨리스는 환불받을 수 있는 방법이 있을 때까지 비트코인을 2-of-2 주소에 넣을 수 없다. 기본적으로 이 계약을 체결하기 전에 앨리스는 출구 전략을 계획해야 한다.

"혼전 계약서(prenup)"의 법적 구성을 생각해보자. 두 사람이 결혼을 하면 두 사람의 재산은 관할권에 따라 법으로 묶이게 된다. 결혼 전, 두 사람이 이혼할 경우 자산을 어떻게 분리할지 명시하는 계약서에 서명한다.

비트코인에서도 비슷한 계약을 만들 수 있다. 예를 들어, 혼전 계약서 같은 기능을 하는 환불 트랜잭션을 생성하여 당사자가 다중 서명 자금 주소에 자금이 묶이기 전에 채널의 자금을 어떻게 분할할지 결정할 수 있도록 할 수 있다.

### 사전 서명된 환불 거래 만들기

앨리스는 펀딩 트랜잭션을 구성한 후 즉시 환불 트랜잭션을 구성한다. (마찬가지로 브로드캐스팅하지 않음.) 환불 트랜잭션은 2-of-2 다중 서명 출력을 앨리스의 지갑으로 다시 보내는 트랜잭션이다. 이 환불 트랜잭션을 약정 트랜잭션(commitment transaction)이라 부르는 이유는 두 채널 파트너가 채널 잔액을 공정하게 분배할 것을 약속하기 때문이다. 여기서는 앨리스가 채널에 자금을 조달했기 때문에 앨리스가 전체 잔액을 받고, 앨리스와 밥 모두 이 트랜잭션을 통해 앨리스에게 환불하기로 약속한다.

실제로는 조금 더 복잡하지만, 여기서는 간단하게 앨리스가 아래와 같은 환불 트랜잭션을 구성한다고 가정한다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0705.png" width="700">
      그림 5. 앨리스가 환불 트랜잭션을 만든다.  
  </figure>

<br/>
<br/>
이 장의 뒷부분에서 채널 잔액을 다양한 금액으로 분배하기 위해 더 많은 약정 트랜잭션이 만들어지는 방법을 살펴본다.

### 브로드캐스팅하지 않고 트랜잭션 연결하기

이제 앨리스는 환불 트랜잭션을 포함한 두 트랜잭션을 구성했다. 하지만 이것이 어떻게 가능한지 궁금할 수 있다. 앨리스는 자금 조달 트랜잭션을 아직 비트코인 블록체인에 브로드캐스팅하지 않았다. 따라서, 네트워크 노드는 해당 트랜잭션을 알 수 없다. 환불 트랜잭션은 펀딩 트랜잭션의 출력(outputs) 하나를 소비하도록 구성되었지만, 해당 출력 역시 아직 존재하지 않는다. 확인되지 않은 출력을 어떻게 사용하는 것이 어떻게 가능할까?

환불 트랜잭션은 아직 유효한 트랜잭션이 아니다. 유효한 트랜잭션이 되기 위해 두 가지 일이 일어나야 한다.

1) 환불 트랜잭션이 비트코인 네트워크에 브로드캐스팅되어야 한다. (라이트닝 네트워크의 보안을 위해 비트코인 블록체인의 승인이 필요하지만, 트랜잭션을 체인화하기 위해서는 승인이 필수가 아니다.)

2) 환불 트랜잭션의 입력에는 앨리스와 밥의 서명이 필요하다.

아직 위 두 가지 일이 일어나지 않은 상태이고, 앨리스의 노드가 펀딩 트랜잭션을 브로드캐스팅하지 않았더라도 앨리스는 여전히 환불 트랜잭션을 구성할 수 있다. 이는 앨리스가 펀딩 트랜잭션의 해시를 계산하고 이를 환불 트랜잭션의 입력으로 참조할 수 있기 때문이다.

그림 5.에서 앨리스가 펀딩 트랜잭션 해시로 6da3c2...387710을 계산한 것이 보이는가? 펀딩 트랜잭션이 브로드캐스팅되면 해당 해시는 펀딩 트랜잭션의 트랜잭션 ID로 기록된다. 따라서 펀딩 트랜잭션의 0번 출력(2-of-2 주소 출력)은 출력 ID 6da3c2...387710:0으로 참조된다. 펀딩 트랜잭션이 아직 블록체인에 존재하지 않더라도 해당 펀딩 트랜잭션 출력을 사용하여 펀딩 트랜잭션을 구성할 수 있는데, 이는 앨리스가 승인될 식별자(트랜잭션 ID)가 무엇인지 알기 때문이다.

즉, 앨리스는 펀딩 트랜잭션이 승인되면 해당 참조가 유효하므로 환불 트랜잭션도 유효하다는 것을 알고 아직 존재하지 않는 출력을 참조하여 연쇄 트랜잭션을 생성할 수 있는 것이다. 트랜잭션이 브로드캐스팅되기 전 체인화를 하는 이 방법은 2017년 8월에 도입된 분리된 증인(Segregated Witness)를 통해 가능해졌다. 

### 서명 분리(Segregated Witness)로 거래 가변성 해결

앨리스는 승인 전에 펀딩 트랜잭션의 트랜잭션 ID를 알아야 한다. 하지만 2017년 8월 분리된 증인(세그윗)이 도입되기 전에는 이 방식으로는 앨리스를 보호하기에 충분하지 않았다. 세그윗 이전에는 트랜잭션에 서명(증인)이 포함되어 트랜잭션 ID로 변환되는 방식을 사용했기 때문에 제 3자가 트랜잭션 ID를 위조(수정)한 대체 버전의 트랜잭션을 브로드캐스팅할 수 있었다. 이를 트랜잭션 가변성(Malleability)이라고 하며, 세그윗 이전에는 이 문제로 인해 무기한의 안전한 평생 결제 채널을 구현하기 어려웠다.

밥이 앨리스의 펀딩 트랜잭션이 승인되기 전 수정된 다른 트랜잭션 ID를 가진 복제본을 생성할 수 있다면, 밥은 앨리스의 환불 트랜잭션을 무효로 만들고 앨리스의 비트코인을 탈취할 수 있다. 앨리스가 자금을 받기 위해서는 밥의 서명을 받아야하고 이로 인해 쉽게 협박당할 수 있다. 밥이 자금을 훔칠 수는 없지만 앨리스가 자금을 돌려받지 못하도록 막을 수는 있다.

세그윗 도입으로 제 3자의 관점에서 확인되지 않은 트랜잭션 ID는 변경할 수 없게 되면서 앨리스는 펀딩 트랜잭션 ID가 변경되지 않을 것이라는 것을 확신할 수 있게 되었다. 결과적으로 앨리스는 환불 거래에 대한 밥의 서명을 받으면 자금을 회수할 수 있다는 것을 확신할 수 있다. 이제 앨리스는 자금을 다중 서명에 잠그기 전에 비트코인으로 '혼전 계약서'와 같은 기능을 구현할 수 있는 방법을 갖게 되었다.

  > 💡 서명 대체
  >
  > 앨리스가 생성하고 서명한 트랜잭션을 앨리스의 키를 가지고 있지 않은 밥이 어떻게 변경할 수 있는지 궁금할 수 있다. 이는 메시지에 대한 ECDSA 서명은 고유하지 않다는 특성에 기인한다. 유효한 트랜잭션에 포함된 서명을 알면 여전히 유효하지만 다른 서명을 생성할 수 있다. 세그윗이 트랜잭션 다이제스트 알고리즘에서 서명을 제거하기 전에 밥은 서명을 다른 트랜잭션 ID를 생성하는 동등한 유효한 서명으로 대체하여 펀딩 트랜잭션과 환불 트랜잭션 사이의 체인을 끊을 수 있었다.

#### `funding_created` 메시지

이제 앨리스가 필요한 트랜잭션을 구성했으므로 채널 구성 메시지 흐름이 계속된다. 앨리스가 밥에게 `funding_created` 메시지를 전송한다.

<br>
`funding_created` 메시지
```
[32*byte:temporary_channel_id]
[sha256:funding_txid]
[u16:funding_output_index]
[signature:signature]
```

이 메시지를 통해 앨리스는 밥에게 결제 채널을 고정하는 펀딩 트랜잭션의 주요 정보를 전달한다.

***funding_txid*** <br>
펀딩 트랜잭션의 트랜잭션 ID(TxID)로, 채널이 설정된 후 채널 ID를 생성하는 데 사용된다.

***funding_output_index*** <br>
출력 인덱스이므로 밥은 트랜잭션의 어떤 출력(예: 출력 `0`)이 앨리스가 펀딩한 2-of-2 다중 서명 출력인지 알 수 있다. 이는 채널 ID를 형성하는 데에도 사용된다.

마지막으로, 앨리스는 2-of-2 다중 서명에서 지출하는 데 사용되는 앨리스의 `funding_pubkey`에 해당하는 서명도 전송한다. 밥이 자신만의 약정 트랜잭션을 생성해야할 때 이것이 필요하다. 이 약정 트랜잭션에는 앨리스가 제공한 서명이 필요하다. 앨리스와 밥의 약정 트랜잭션은 약간 다르게 생겼으며 서명도 다르다. 상대방의 약정 트랜잭션이 어떻게 생겼는지 아는 것은 매우 중요하며 유효한 서명을 제공하기 위한 프로토콜의 일부이다.

  > 💡 서명 전송  
  >
  > 라이트닝 프로토콜에서는 노드가 서명된 전체 트랜잭션 대신 서명을 전송하는 경우가 많다. 이는 어느 쪽이든 동일한 트랜잭션을 재구성할 수 있으므로 서명만 있으면 트랜잭션이 유효함을 보장하기 때문이다. 전체 트랜잭션이 아닌 서명만 전송하면 네트워크 대역폭도 많이 절약할 수 있다. 

#### `funding_signed` 메시지

앨리스로부터 `funding_created` 메시지를 받은 밥은 이제 펀딩 트랜잭션 ID와 출력 인덱스를 알 수 있다. 채널 ID는 펀딩 트랜잭션 ID와 출력 인덱스의 비트 연산 "배타적 논리합(exclusive or, XOR)"으로 만든다.

```
channel_id = funding_txid XOR funding_output_index
```

보다 정확하게는 `channel_id`는, 펀딩 UTXO의 32바이트 표현으로 펀딩 TxID의 하위 2바이트와 펀딩 출력 인덱스를 XOR하여 생성된다.

또한 밥은 2-of-2 다중 서명을 구성한 밥의 `funding_pubkey`를 기반으로 앨리스에게 환불 트랜잭션에 대한 서명을 보내야 한다. 밥은 이미 환불 트랜잭션을 가지고 있지만, 이는 앨리스가 필요한 모든 서명으로 환불 트랜잭션을 완료하고 문제가 발생할 경우 자금을 환불받을 수 있는지 확인할 수 있게 한다.

밥은 `funding_signed` 메시지를 작성하여 앨리스에게 보낸다. 

<br>
`funding_signed` 메시지
```
[channel_id:채널_id]
[서명:서명]
```

### 펀딩 트랜잭션 브로드캐스팅하기

밥으로부터 `funding_signed` 메시지를 받은 앨리스는 이제 환불 트랜잭션에 서명하는 데 필요한 두 가지 서명을 모두 받았다. 이제 앨리스의 안전한 "출구 전략"이 생겼으므로 자금이 잠길 염려 없이 펀딩 트랜잭션을 브로드캐스팅할 수 있다. 문제가 발생하면 앨리스는 밥의 도움 없이도 환불 트랜잭션을 브로드캐스팅하고 자금을 돌려받을 수 있다.

이제 앨리스는 비트코인 네트워크에 펀딩 트랜잭션을 전송하여 블록체인에 채굴할 수 있도록 한다. 앨리스와 밥은 모두 이 트랜잭션을 지켜보며 비트코인 블록체인에서 `minimum_depth` 만큼 승인(예: 6번 승인)될 때까지 기다린다.

  > 💡 서명 확인
  > 
  > 당연히 앨리스는 비트코인 프로토콜을 사용해 밥이 보낸 서명이 실제로 유효한지 확인한다. 만약 밥이 앨리스에게 잘못된 데이터를 전송했다면, 앨리스의 출구 전략이 무산되므로 이 과정은 매우 중요하다.

#### `funding_locked` 메시지

펀딩 트랜잭션이 필요한 승인 횟수에 도달하면 앨리스와 밥은 서로에게 `funding_locked` 메시지를 보낸다. 이 메시지는 채널을 사용할 준비가 된 것임을 의미한다.

<br>

## 채널을 통해 결제하기

채널이 설정되어 초기 상태에서는 모든 용량(140,000 사토시)이 앨리스 측에 있다. 즉, 앨리스는 채널을 통해 밥에게 송금할 수 있지만 밥은 아직 앨리스에게 송금할 자금이 없다.

이어서 결제 채널에서 결제가 이루어지는 방식과 채널 상태가 업데이트되는 방식을 다룬다.

앨리스가 밥의 커피숍에서 계산서를 지불하기 위해 밥에게 70,000사토시를 보내려고 한다고 가정해 보자.


### 잔액 쪼개기

원칙적으로 앨리스가 밥에게 송금하는 것은 채널 잔액을 재분배하는 문제이다. 결제가 전송되기 전 앨리스는 140,000 사토시를 가지고 있고 밥은 가진 잔액이 없지만, 70,000 사토시가 전송된 후 앨리스는 70,000 사토시를, 밥은 70,000 사토시를 보유하게 된다.

따라서 앨리스와 밥은 2-of-2 다중 서명을 통해 앨리스와 밥에게 해당 잔액을 지불하는 트랜잭션을 생성하고 서명하기만 하면 된다. 이 업데이트된 트랜잭션을 약정 트랜잭션이라 한다.

앨리스와 밥은 일련의 약속을 통해 채널 상태를 발전시킴(advancing the channel state)으로써 결제 채널을 운영한다. 각 약속은 채널에 흐르는 결제를 반영하여 잔액을 업데이트한다. 앨리스와 밥은 모두 새로운 약속을 시작하여 채널을 업데이트할 수 있다.

그림 6.에서 여러 개의 커미션 트랜잭션을 볼 수 있다.

그림에 표시된 첫 번째 약정 트랜잭션은 앨리스가 채널에 펀딩하기 전에 구성한 환불 트랜잭션이다. commitment #0에 해당한다. 앨리스가 밥에게 70,000 사토시를 지급한 후, 새로운 약정 트랜잭션(commitment #1)은 앨리스와 밥에게 각자의 잔액을 지급하는 두 개의 출력을 갖는다. 앨리스가 밥에게 각각 10,000 사토시와 20,000 사토시를 추가로 지불하는 두 개의 약정 트랜잭션(commitment #2와 commitment #3)도 포함되어 있다.

서명되고 유효한 각 약정 트랜잭션은 언제든지 채널 파트너가 비트코인 네트워크에 브로드캐스팅하여 채널을 닫는 데 사용할 수 있다. 두 파트너 모두 가장 최근의 약정 트랜잭션을 보유하고 있고 언제든지 사용할 수 있기 때문에 이를 브로드캐스팅하지 않고 그냥 보유할 수도 있다. 이는 채널에서 공정하게 채널을 닫을 수 있도록 보장하는 것이다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0706.png" width="700">
    <br>
      그림 6. 여러 개의 약정 트랜잭션
    <br>  
  </figure>

### 약정 경쟁

어떻게 앨리스와 밥의 펀딩 트랜잭션의 동일한 2-of-2 출력을 사용하는 여러 개의 약정 트랜잭션을 생성할 수 있는지 궁금할 것이다. 이는 비트코인 시스템이 방지하고자 하는 "이중 지불" 아닌가?

그렇다. 라이트닝은 이중 지불을 방지하는 비트코인 기능에 의존하고 있다. 채널에서 앨리스와 밥이 얼마나 많은 약정 트랜잭션을 생성하고 서명하든, 실제로 비트코인 블록체인에는 단 하나의 트랜잭션만 확정될 수 있다.

앨리스와 밥이 이 트랜잭션을 보유만 하고 (메인넷으로) 브로드캐스팅하지 않는 한, 해당 출력은 사용되지 않는다. 약정 트랜잭션이 전파되고 승인되어야 출력이 소비된다. 앨리스나 밥이 두 개 이상의 약정 트랜잭션을 브로드캐스팅하려고 하면 그 중 하나만 승인되고 나머지는 이중 지불 시도로 거부될 것이다.

두 개 이상의 약정 트랜잭션이 브로드캐스팅되는 경우, 포함된 수수료 금액, 트랜잭션의 전파 속도, 네트워크 토폴로지 등 다양한 요소로 인해 특정 트랜잭션이 먼저 확정된다. 이는 본질적으로 결과를 예측할 수 없는 경쟁이다. 따라서 누군가 속임수를 쓸 수 있을 것 같은 안전하지 않은 방식이다. 

### 이전 약정 거래로 부정 행위하기

그림 6.에서 약정 트랜잭션을 좀 더 자세히 살펴보자. 네 개의 약정 트랜잭션이 모두 서명되어 유효하다. 하지만 마지막 트랜잭션만 가장 최근 채널 잔액을 정확하게 반영한다. 앨리스가 이전(old) 약정 트랜잭션을 브로드캐스팅하고 비트코인 블록체인에서 승인받음으로써 부정 행위를 할 수 있는 특정 시나리오를 보자. 앨리스가 commitment #0을 전송하고 승인을 받는다고 가정할 때, 앨리스는 채널을 닫고 14만 사토시를 모두 가져가게 된다. 실제로 이 예시에서는 commitment #3을 제외한 모든 약정 트랜잭션을 전송하면 앨리스의 잔액이 늘어나면서 채널에 반영된 결제 일부를 "취소"할 수 있다.

다음 섹션에서는 라이트닝 네트워크가 어떻게 이 문제를 해결하는지, 즉 철회(revocation)와 페널티 메커니즘을 통해 채널 파트너가 이전 약정 트랜잭션을 사용하지 못하도록 방지하는 방법을 살펴본다. 엘투(eltoo) 채널과 같이 오래된 약정 트랜잭션의 전송을 방지하는 다른 방법도 있지만, 이는 입력 리바인딩(input rebinding)이라는 비트코인 업그레이드를 필요로 한다. 

### 이전 약정 거래 철회

비트코인 거래는 만료되지 않으며 취소할 수 없다. 또한, 일단 전송된 후에는 중단하거나 검열할 수 없다. 그렇다면 다른 사람이 이미 서명한 거래를 어떻게 "철회"할 수 있을까?

라이트닝에 사용된 솔루션은 공정 프로토콜의 또 다른 예시이다. 트랜잭션 브로드캐스팅을 제어하는 대신, 사기꾼이 이전 약정 트랜잭션을 전송하는 것이 최선의 이익이 되지 않도록 하는 페널티 메커니즘이 내장되어 있다. 사기꾼은 언제든지 트랜잭션을 브로드캐스팅할 수 있지만, 그렇게 할 경우 손해를 볼 가능성이 높다.

  > 💡 철회(revoking), 잘못된 용어 
  > 
  > "철회"라는 단어는 이전 약정 트랜잭션이 어떻게든 무효화되어 브로드캐스팅 및 승인이 불가능하다는 의미이므로 엄격히는 잘못된 표현이다. 유효한 트랜잭션인 이상 취소할 수 없으므로 이는 사실과 다르다. 대신, 라이트닝 프로토콜은 페널티 메커니즘을 사용해 오래된 약정 트랜잭션을 브로드캐스팅한 채널 파트너를 처벌한다.

라이트닝 프로토콜의 철회 및 페널티 메커니즘을 구성하는 세 가지 요소는 다음과 같다.

***비대칭 약정 트랜잭션(Asymmetric commitment transactions)*** <br>
앨리스의 약정 트랜잭션은 밥이 보유한 트랜잭션과 약간 다르다.

***지연된 소비(Delayed spending)*** <br>
약정 트랜잭션을 보유한 당사자에 대한 지급은 지연(timelocked)되지만, 상대방에 대한 지급은 즉시 청구할 수 있다.

***철회 키(Revocation keys)*** <br>
이전 약정 트랜잭션에 대한 처벌 옵션을 해제하는 데 사용한다.


### 비대칭 약정 거래

앨리스와 밥은 약간 다른 트랜잭션을 보유한다. 여러 약정 트랜잭션 중 commitment #2를 구체적으로 살펴보자. 

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0707.png" width="700">
      그림 7. commitment #2
  </figure>

<br/>
<br/>
앨리스와 밥은 아래 그림 8.처럼 같은 트랜잭션에 대한 두 가지 다른 트랜잭션을 갖는다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0708.png" width="800">
      그림 8. 비대칭 약정 트랜잭션
  </figure>

<br/>
<br/>

라이트닝 프로토콜에서는 두 채널 파트너가 어느 쪽에 있는지에 따라 self(또는 local)와 remote로 칭한다. 각 채널 파트너에게 지불하는 출력을 각각 `to_local` 및 `to_remote`라고 한다.

비대칭 트랜잭션에서 앨리스는 60,000 사토시(앨리스의 키로 사용 가능)를 `to_self`에 지불하고, 80,000 사토시(밥의 키로 사용 가능)를 `to_remote`에 지불하는 트랜잭션을 보유하고 있다.

밥은 해당 트랜잭션의 거울 이미지로 첫 번째 출력은 80,000 사토시 `to_self`(밥의 키로 사용할 수 있음)와 60,000 사토시 `to_remote`(앨리스의 키로 사용할 수 있음) 트랜잭션을 보유한다.

### 지연된 소비 (`to_self`)

비대칭 트랜잭션을 사용하면 프로토콜이 부정 행위를 한 당사자에게 책임을 쉽게 돌릴 수 있다. 브로드캐스팅 당사자는 항상 기다려야 한다는 불변성은 "정직한" 당사자가 이를 반박하고 자금을 취소할 시간을 확보하게 해준다. 이러한 비대칭성에 의해 양측의 출력이 서로 다른 형태로 나타나는데, `to_local` 출력은 항상 시간이 잠겨있어(timelocked) 즉시 사용할 수 없는 반면, `to_remote` 출력은 즉시 사용할 수 있다.

예를 들어, 앨리스의 약정 트랜잭션에서 그녀에게 지급하는 `to_local` 출력은 432 블록 동안 타임락된 반면, 밥에게 지급하는 `to_remote` 출력은 즉시 사용할 수 있다. 밥의 commitment #2는 이에 대한 거울 이미지로 자신의 (`to_local`) 출력은 타임락되고 앨리스의 `to_remote` 출력은 즉시 사용할 수 있다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0709.png" width="800">
      그림 9. 비대칭, 지연된 약정 트랜잭션
  </figure>

<br/>
<br/>
즉, 앨리스가 보유한 약정 트랜잭션이 브로드캐스팅되고 승인되어 채널을 닫으면 432 블록 동안 잔액을 사용할 수 없지만, 밥은 즉시 잔액을 청구할 수 있다. 반면 밥이 보유한 약정 트랜잭션을 사용하여 채널을 닫으면, 밥은 432 블록 동안 자신의 산출물을 사용할 수 없지만 앨리스는 즉시 자신의 출력을 사용할 수 있다.

이러한 지연은 다른 채널 파트너가 이전 약정 트랜잭션을 브로드캐스팅해야 하는 경우 원격 당사자가 페널티 옵션을 행사할 수 있도록 하기 위해 존재한다.

이 지연은 초기 채널 개설 메시지 흐름 중 `to_self_delay`라는 필드로 협상한다. 채널의 보안을 보장하기 위해 채널의 용량에 따라 값이 조정된다. 즉, 자금이 더 많은 채널은 약정 트랜잭션의 `to_self` 출력 지연이 더 길어진다. 앨리스의 노드는 `open_channel` 메시지에 원하는 `to_self_delay`를 포함시킨다. 밥이 이를 수락하면, 밥의 노드는 `accept_channel` 메시지에 동일한 값의 `to_self_delay`를 포함시킨다. 동의하지 않으면 채널이 개설이 거부된다.

### 철회 키

앞서 설명한 것처럼 '철회된(revoked)' 트랜잭션은 트랜잭션을 사용할 수 없음을 의미하기 때문에 "철회/취소"라는 단어는 오해의 소지가 있다.

트랜잭션이 사용 후 철회된 경우, 채널 파트너 중 한 명이 페널티 트랜잭션을 생성하여 채널 자금을 모두 가져갈 수 있다.

이것이 작동하는 방식은 `to_local` 출력은 시간 제한이 있을 뿐만 아니라 스크립트의 두 가지 지출 조건에 의해서이다. 즉, 시간 제한 만큼의 지연 후 스스로에게 지출하거나 이 약정에 대한 철회 키를 사용하여 즉시 원격으로 지출할 수 있다. 


  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0710.png" width="800">
      그림 10. 비대칭, 지연 및 철회 가능한 약정 트랜잭션
  </figure>

<br/>

## 약정 트랜잭션

이제 약정 트랜잭션의 구조와 비대칭, 지연, 철회 가능한 약정이 필요한 이유를 이해했으니, 이를 구현하는 비트코인 스크립트를 살펴본다.

약정 트랜잭션의 첫 번째(`to_local`) 출력은[ BOLT #3: Commitment Transaction, `to_local` 출력](https://github.com/lightning/bolts/blob/master/03-transactions.md#to_local-output)에 정의되어 있다.

```
OP_IF
    # Penalty transaction
    <revocationpubkey>
OP_ELSE
    <to_self_delay>
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    <local_delayedpubkey>
OP_ENDIF
OP_CHECKSIG
```

이 스크립트는 조건부 스크립트로, 두 조건 중 하나가 충족되면 출력을 사용할 수 있다. 

첫 번째 절은 <&zwj;revocationpubkey>에 서명할 수 있는 모두가 출력을 사용할 수 있도록 허용한다. 두 번째 절은 <to_self_delay> 일정 시간(블록) 동안 잠기며, <local_delayedpubkey>에 서명할 수 있는 사람은 해당 블록만큼 지난 후에야 사용할 수 있다. 예시에서는 <to_self_delay>를 432 블록으로 설정했지만, 이는 두 채널 파트너가 협상하는 설정 가능한 값이다. 일반적으로 채널 용량에 비례하여 `to_self_delay` 타임락 기간이 선택되므로, 용량이 큰 채널(더 많은 자금)일수록 당사자를 보호하기 위해 `to_self_delay` 타임락이 길어진다.

첫 번째 절은 <&zwj;revocationpubkey>에 서명할 수 있는 모든 사람이 출력을 사용할 수 있도록 허용한다. 이 스크립트의 보안에 대한 중요한 요구사항은 원격 당사자가 일방적으로 `revocationpubkey`로 서명할 수 없다는 것이다. 이것이 왜 중요한지 알아보려면 원격 당사자가 이전에 해지된 약정(revoked commitment)을 위반하는 시나리오를 생각해 보라. 이 키로 서명할 수 있다면 해지 조항을 직접 가져와 채널의 모든 자금을 훔칠 수 있다. 대신, 당사자(로컬)와 원격 당사자 모두의 정보를 기반으로 각 상태에 대한 해지 공개키를 도출한다. 대칭 암호화와 비대칭 암호화를 영리하게 사용하여 양쪽 모두 취소 공개키를 계산할 수 있지만, 아래 자세히 설명된 것처럼 정직한 자기 당사자만 자신의 비밀 정보를 바탕으로 개인키를 계산할 수 있도록 허용한다.

**철회 및 약정 비밀 도출** <br>
양측은 초기 채널 개설 시 협상 메시지에 `revocation_basepoint`과 `first_per_commitment_point`을 보낸다. `revocation_basepoint`는 채널의 수명 동안 정적인 반면, 각각의 새로운 채널 상태는 새로운 `first_per_commitment_point`에 따라 달라진다.

이 정보가 주어지면 다음과 같은 일련의 타원 곡선 및 해싱 연산을 통해 각 채널 상태에 대한 `revocationpubkey`가 도출된다.

```
revocationpubkey = revocation_basepoint * sha256(revocation_basepoint || per_commitment_point) + per_commitment_point * sha256(per_commitment_point || revocation_basepoint)
```

타원 곡선이 정의되는 아벨군의 교환 법칙에 따라 원격 당사자가 `per_commitment_secret`(`per_commitment_point`에 대한 개인키)을 공개하면, self측은 다음 연산을 통해 `revocationpubkey`에 대한 개인키를 도출할 수 있다.

```
revocation_priv = (revocationbase_priv * sha256(revocation_basepoint || per_commitment_point)) + (per_commitment_secret * sha256(per_commitment_point || revocation_basepoint)) mod N
```

이것이 실제로 작동하는 이유를 보려면, `revocationpubkey`에 대한 원래 공식의 공개키 계산을 교환(순서를 바꾸어도 동일)하고 확장할 수 있다는 점에 주목하자.

```
revocationpubkey = G*(revocationbase_priv * sha256(revocation_basepoint || per_commitment_point) + G*(per_commitment_secret * sha256(per_commitment_point || revocation_basepoint))
                 = revocation_basepoint * sha256(revocation_basepoint || per_commitment_point) + per_commitment_point * sha256(per_commitment_point || revocation_basepoint))
```

즉, `revocationbase_priv`와 `per_commitment_secret`을 모두 알고 있는 당사자만 `revocationbase_priv`를 도출할 수 있으며, 이를 사용하여 `revocationpubkey`에 서명할 수 있다. 이 작은 트릭이 바로 라이트닝 네트워크에서 사용되는 공개키 기반 취소 시스템을 안전하게 만드는 비결이다.

  > 💡 `to_self_delay`의 의미
  > 
  > CHECKSEQUENCEVERIFY와 함께 약정 트랜잭션에 사용되는 타임락은 상대적인 타임락이다. 해당 출력의 승인을 기준으로 경과된 블록을 계산한다. 다시 말해, 이 약정 트랜잭션이 전파되고 승인된 후 `to_self_delay` 블록이 생성될 때까지는 이 출력을 사용할 수 없다.

약정 트랜잭션의 두 번째 출력(`to_remote`) 출력은 [BOLT #3: Commitment Transaction, `to_remote` 출력](https://github.com/lightning/bolts/blob/master/03-transactions.md#to_remote-output)에 정의되어 있으며, 가장 간단한 형태는 <remote_pubkey>에 대한 P2WPKH(Pay-to-Witness-Public-Key-Hash)로, 이는 단순히 <remote_pubkey>에 서명할 수 있는 소유자에게 지불하는 것을 의미한다.

이제 약정 트랜잭션이 자세히 정의되었으니 앨리스와 밥이 채널 상태를 발전시키고, 새 약정 트랜잭션을 생성 및 서명하고, 이전 트랜잭션을 철회하는 방법을 살펴본다.

<br>

## 채널 상태 변경하기 (Advancing the Channel State)

채널 상태를 발전시키기 위해 앨리스와 밥은 두 개의 메시지, `commitment_signed`와 `revoke_and_ack`를 교환한다. 채널 파트너 중 한 명이 채널 상태에 대한 업데이트가 있을 때 `commitment_signed` 메시지를 보낼 수 있다. 그러면 다른 채널 파트너는 이전 약정을 철회하고 새 약정을 승인하기 위해 `revoke_and_ack`으로 응답할 수 있다.

그림 11.에서 앨리스와 밥이 두 쌍의 `commitment_signed`와 `revoke_and_ack`을 주고받는 것을 볼 수 있다. 첫 번째 흐름은 앨리스가 시작한 상태 업데이트(왼쪽에서 오른쪽으로 `commitment_signed`)에 대해 밥이 응답(오른쪽에서 왼쪽으로 `revoke_and_ack`)하는 것을 보여준다. 두 번째 흐름은 밥이 시작하고 앨리스가 응답하는 상태 업데이트를 보여준다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0711.png" width="700">
      그림 11. 약정 및 철회 메시지 흐름 <br/>
  </figure>

  > 💡 그림 11. 다이어그램 오류
  > 
  > B가 보내는 `commitment_signed` 메시지와 그 응답 `revoke_and_ack` 메시지의 화살표 기울기가 잘못 표현되어있다.

### `commitment_signed` 메시지

`commitment_signed` 메시지의 구조는 [BOLT #2: Peer Protocol, `commitment_signed`](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#committing-updates-so-far-commitment_signed)에 정의되어 있다.

<br>

`commitment_signed` 메시지
```
[channel_id:channel_id]
[signature:signature]
[u16:num_htlcs]
[num_htlcs*signature:htlc_signature]
```

***channel_id*** <br>
채널의 식별자

***signature*** <br>
새로운 원격 약정에 대한 서명 

***num_htlcs*** <br>
이 약정에서 업데이트된 HTLC의 수

***htlc_signature*** <br>
업데이트들에 대한 서명

앨리스의 `commitment_signed` 메시지는 밥에게 새로운 약정 트랜잭션에 필요한 서명(2-of-2의 엘리스 부분)을 제공한다.

### `revoke_and_ack` 메시지

이제 밥은 새로운 약정 트랜잭션을 가지고 있으므로 앨리스에게 철회 키를 제공하여 이전 약정을 해지하고 앨리스의 서명으로 새로운 약정을 생성할 수 있다.

`revoke_and_ack` 메시지는 [BOLT #2: Peer Protocol, `revoke_and_ack`](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#completing-the-transition-to-the-updated-state-revoke_and_ack)에 정의되어 있다.

<br>

`revoke_and_ack` 메시지
```
[channel_id:channel_id]
[32*byte:per_commitment_secret]
[point:next_per_commitment_point]
```

***channel_id*** <br>
채널의 식별자

***per_commitment_secret*** <br>
이전 약정에 대한 철회 키를 생성하며, 효과적으로 트랜잭션을 철회하는 데 사용된다.

***next_per_commitment_point*** <br>
새로운 약정에 대해 이것이 나중에 취소될 수 있도록 `revocation_pubkey`를 빌드하는 데 사용된다.

### 철회와 재약정

앨리스와 밥의 상호작용을 좀 더 자세히 살펴보자.

앨리스는 밥에게 새로운 약정을 만들 수 있는 수단을 제공하고 있다. 그 다음 밥은 이전 약정을 철회하여 엘리스에게 이를 사용하지 않을 것을 보장한다. 앨리스는 이전 약정을 게시한 밥을 처벌할 수 있도록 철회 키를 가지고 있어야만 새 약정을 신뢰할 수 있다. 밥 입장에서는 앨리스에게 새 약정에 대한 서명이 있기 때문에 밥에게 불이익을 줄 수 있는 키를 제공함으로써 이전 약정을 안전하게 취소할 수 있다.

밥이 `revoke_and_ack`으로 응답할 때 앨리스에게 `per_commitment_secret`을 제공한다. 이 비밀은 이전 약정에 대한 철회 서명 키를 구성하는 데 사용할 수 있으며, 앨리스는 페널티를 행사하여 모든 채널 자금을 압류할 수 있다.

밥이 앨리스에게 이 비밀을 제공한 즉시 이전 약정을 브로드캐스팅해서는 안 된다. 만약 그렇게 하면 앨리스가 모든 자금을 가져감으로써 밥에게 페널티를 줄 수 있는 기회를 주게 되는 것이다. 본질적으로 밥은 앨리스에게 이전 약정을 브로드캐스팅한 것에 대한 책임을 물을 수 있는 권한을 부여한 것이며, 사실상 이전 약정을 사용할 수 있는 권한을 취소한 것이다.

앨리스가 밥으로부터 `revoke_and_ack`을 받으면, 이전 약정을 브로드캐스팅하면 밥이 불이익을 받길 감내할 것을 확신할 수 있다. 이제 앨리스는 밥이 이전 약정을 브로드캐스팅할 경우 페널티 트랜잭션을 생성하는 데 필요한 키를 갖게 되었다.

### 부정 행위와 페널티

실제로 앨리스와 밥은 서로의 부정 행위를 모니터링해야 한다. 이들은 비트코인 블록체인에서 자신들이 운영 중인 채널과 관련된 모든 약정 트랜잭션을 모니터링한다. 온체인에서 승인된 약정 트랜잭션이 발견되면, 가장 최근 약정인지를 확인한다. "오래된" 약정인 경우 즉시 페널티 트랜잭션을 구성하고 브로드캐스팅해야 한다. 페널티 트랜잭션은 `to_local`과 `to_remote` 출력을 모두 소비하여 채널을 닫고 부정 행위를 당한 채널 파트너에게 두 잔액을 모두 보낸다.

양측에서 통과된 철회된 약정에 대한 "약정 번호"를 더 쉽게 추적할 수 있도록 각 약정은 실제로 트랜지션의 잠금 시간 및 시퀀스 필드 내에 약정 번호를 인코딩한다. 프로토콜 내에서 이 특수 인코딩을 "상태 힌트"라고 한다. 당사자가 현재 약정 번호를 알고 있다고 가정하면, 상태 힌트를 사용하여 브로드캐스팅된 트랜잭션이 철회된 약정인지, 만약 그렇다면 어떤 약정 번호가 위반되었는지 쉽게 인식할 수 있으며, 이 번호는 철회 시크릿 트리(shachain)에서 어떤 시크릿을 사용해야 하는지 쉽게 조회하는 데 사용되기 때문이다.

실제로 상태 힌트는 눈에 잘 띄는 인코딩 대신, 난독화된 상태 힌트로 대체된다. 이 난독화는 먼저 채널 양쪽의 펀딩 공개키를 사용하여 결정론적으로 생성된 무작위 바이트 집합으로 현재 약정 번호를 XOR하는 방식으로 이루어진다. 약정 트랜잭션 내에서 상태 힌트를 인코딩하기 위해 잠금 시간과 시퀀스에 걸쳐 총 6바이트(잠금 시간 24비트, 시퀀스 24비트)가 사용되므로 XOR에 사용할 무작위 바이트는 6바이트가 필요하다. 이 6바이트를 얻기 위해 양쪽 모두 응답자의 펀딩 키에 연결된 개시자의 펀딩 키의 SHA-256 해시를 얻는다. 현재 약정 높이를 인코딩하기 전에 이 상태 힌트 난독기를 사용하여 정수를 XOR한 다음 잠금 시간의 하위 24비트와 시퀀스의 상위 64비트로 인코딩한다.

앨리스와 밥 노드 간 채널에서의 구체적인 페널티 트랜잭션의 예를 보자. 그림 12.에서 앨리스와 밥의 채널에 있는 네 개의 약정을 볼 수 있다. 앨리스는 밥에게 세 번 지불했다.

* 70,000 사토시를 밥에게 지불하고 commitment #1이 약정됨.
* 10,000 사토시를 밥에게 지불하고 commitment #2가 약정됨.
* 20,000 사토시를 밥에게 지불하고 commitment #3이 약정됨.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0712.png" width="700">
    <br>
      그림 12. 철회된 트랜잭션과 최근 약정 트랜잭션
  </figure>

<br/>

새로운 약정 마다 앨리스는 이전 약정을 철회한다. 채널의 현재 상태와 정확한 잔액은 commitment #3이다. 이전 약정은 모두 철회되었으며, 밥은 앨리스가 이 철회된 약정 중 하나를 브로드캐스팅하려고 할 때를 대비해 해당 약정에 대해 페널티 트랜잭션을 발행하는 데 필요한 키를 가지고 있다.

이전 상태의 약정 트랜잭션으로 앨리스가 현재 채널 잔액보다 더 많은 잔액을 받을 수 있으므로 부정 행위를 할 유인이 있을 수 있다. 예를 들어, 앨리스가 commitment #1을 브로드캐스팅 했다고 가정해 보자. 이 약정 트랜잭션은 앨리스에게 70,000사토시, 밥에게 70,000사토시를 지급한다. 만약 앨리스가 이 트랜잭션을 브로드캐스팅하고 하고 자신의 `to_local` 출력을 사용하는데 성공한다면, 앨리스는 밥에게 지불한 마지막 두 번의 지불을 롤백하여 사실상 밥으로부터 30,000 사토시를 훔친 셈이 된다.

앨리스는 큰 위험을 감수하고 취소된 commitment #1을 브로드캐스팅하여 밥으로부터 30,000 사토시를 훔치기로 결정한다. 

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0713.png" width="550">
      그림 13. 앨리스의 부정 행위
  </figure>

<br/>
<br/>
보다시피 앨리스의 이전 약정에는 두 개의 출력이 있는데, 하나는 자신에게 70,000 사토시(`to_local` 출력)를 지불하고 다른 하나는 밥에게 70,000 사토시를 지불하는 것이다. 앨리스는 432 블록(3일)의 타임락이 있기 때문에 아직 70,000 사토시를 `to_local` 출력에 사용할 수 없다. 앨리스는 이제 밥이 3일 동안 눈치채지 못하길 바라고 있는 상황이다.

하지만 안타깝게도 밥의 노드는 비트코인 블록체인을 부지런히 모니터링하고 있으며, 오래된 약정 트랜잭션이 전파되고 결국 온체인에서 승인되는 것을 목격한다.

밥의 노드는 즉시 페널티 트랜잭션을 브로드캐스팅한다. 전파된 이전 약정은 앨리스에 의해 철회되었으므로 밥은 앨리스가 전송한 `per_commitment_secret`을 가지고 있다. 밥은 이 비밀을 사용하여 `revocation_pubkey`에 대한 서명을 생성한다. 앨리스는 432 블록을 기다려야 하지만, 밥은 두 출력을 즉시 사용할 수 있다. 밥은 개인키로 원래부터 밥에게 지불될 `to_remote` 출력을 사용할 수 있다. 또한 철회 키의 서명으로 앨리스를 위한 출력을 사용할 수도 있다. 밥의 노드는 그림 14.와 같은 페널티 트랜잭션을 브로드캐스팅한다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0714.png" width="800">
      그림 14. 부정 행위와 페널티
  </figure>

<br/>
<br/>
밥의 페널티 트랜잭션은 자신의 지갑으로 140,000 사토시를 지불하여 채널의 전체 용량을 가지게 된다. 앨리스는 부정 행위에 실패했을 뿐만 아니라 모든 것을 잃게 되었다!

### 채널 예약금: 페널티에 대한 재정적 부담

여기서 여러분이 다루어야 할 특별한 상황이 있다는 것을 눈치챘을 것이다. 앨리스가 자신의 잔액이 0이 될 때까지 채널을 계속 사용할 수 있다면, 철회된 약정 트랜잭션이 성공하거나 부정 행위자가 적발되더라도 페널티가 0이므로 아무런 처벌을 받지 않고 이전 약정 트랜잭션을 브로드캐스팅하여 채널을 닫을 수 있는 위치에 있을 것이다. 게임 이론의 관점에서 볼 때, 이 상황에서는 부정 행위를 시도하는 비용이 발생하지 않는다. 그렇기 때문에 채널 예약금(reserve)이 필요하며, 이를 담보함으로써 부정 행위를 하려는 사람은 항상 페널티의 위험에 직면하게 된다.

  > 💡 Skin in the Game
  >
  > 원문의 제목은 The Channel Reserve: Ensuring Skin in the Game. 여기에 사용된 "Skin in the game"의 기원은 정확하지 않으나, 나심 니콜라스 탈레브(Nassim Nicholas Taleb)의 한 저서 Skin in the Game: Hidden Asymmetries in Daily Life에서도 제시된 개념이다. '책임을 안고 게임에 임하라'는 비유로, 한국어로 "승부의 책임"이라 번역되기도 한다. 여기서는 채널 참여자의 부정 행위에 대한 책임 즉, 채널 예약금을 예치함으로써 재정적 부담을 지는 것으로 의역하였다. 

<br>

## 채널 닫기 (협력적 폐쇄)

지금까지 채널을 일방적으로 폐쇄할 수 있는 약정 거래를 살펴보았다. 이러한 유형의 채널 폐쇄는 채널을 사용하는 채널 파트너에게 타임락을 강제하기 때문에 이상적이지 않다.

채널을 폐쇄하는 더 좋은 방법은 협력적 폐쇄이다. 협력적 폐쇄에서 두 채널 파트너가 폐쇄 트랜잭션(closing transaction)이라는 각 당사자가 선택한 대상 지갑으로 잔액을 즉시 지급하는 최종 약정 거래에 협상한다. 그런 다음 채널 닫기 흐름을 시작한 파트너가 폐쇄 트랜잭션을 브로드캐스팅한다.

채널 닫기 메시지 흐름은 [BOLT #2: Peer Protocol, Channel Close](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#channel-close)에 정의되어 있다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0715.png" width="600">
      그림 15. 채널 폐쇄 메시지 흐름
  </figure>

### `shutdown` 메시지

채널 종료는 두 채널 파트너 중 하나가 `shutdown` 메시지를 보내는 것으로 시작된다.

<br>

`shutdown` 메시지
```
[channel_id:channel_id]
[u16:len]
[len*byte:scriptpubkey]
```

***channel_id*** <br>
닫길 원하는 채널의 식별자

***len*** <br>
채널 파트너가 잔액을 받으려는 대상 지갑의 스크립트 길이

***scriptpubkey*** <br>
대상 지갑의 비트코인 스크립트, "표준" 비트코인 주소 형식 중 하나(P2PKH, P2SH, P2WPKH, P2WSH 등)

앨리스가 밥에게 `shutdown` 메시지를 보내어 채널을 닫는다고 가정해 보자. 앨리스는 본인 지갑의 비트코인 주소에 해당하는 비트코인 스크립트를 지정한다. 앨리스는 밥에게 "이 지갑에 내 잔액을 지불하는 마감 거래를 하자"고 말한다.

밥은 협력적으로 채널을 닫는 데 동의한다는 `shutdown` 메시지로 응답한다. `shutdown` 메시지에는 지갑 주소에 대한 스크립트가 포함되어 있다.

이제 앨리스와 밥은 서로 사용하고자 하는 지갑 주소를 가지고 있으며, 동일한 폐쇄 트랜잭션을 구성하여 채널 잔액을 정산할 수 있다.

### `closing_signed` 메시지

채널에 미결 약정이나 업데이트가 없고 채널 파트너가 `shutdown` 메시지를 교환했다고 가정하면 이제 이 협력적 폐쇄 작업을 완료할 수 있다.

채널의 펀딩자 앨리스는 밥에게 `closing_signed` 메시지를 보낸다. 이 메시지는 온체인 트랜잭션에 대한 트랜잭션 수수료와 폐쇄 트랜잭션을 위한 앨리스의 서명(2-of-2 다중 서명)을 제안한다. 

<br>

`closing_signed` 메시지
```
[channel_id:channel_id]
[u64:fee_satoshis]
[signature:signature]
```

***channel_id*** <br>
채널 식별자

***fee_satoshis*** <br>
제안된 온체인 트랜잭션 수수료, 사토시 단위

***signature*** <br>
거래 완료를 위한 발신자의 서명

밥은 이 메시지를 받으면 자신이 직접 `closing_signed` 메시지로 답장할 수 있다. 수수료에 동의하면 동일한 제안 수수료와 자신의 서명을 반환하기만 하면 된다. 동의하지 않으면 다른 `fee_satoshis` 수수료를 제안해야 한다.

이 협상은 두 채널 파트너가 수수료에 합의할 때까지 `closing_signed` 메시지를 주고받으며 계속될 수 있다.

앨리스가 마지막 메시지에서 제안한 수수료와 동일한 수수료가 포함된 `closing_signed` 메시지를 받으면 협상이 완료된다. 앨리스가 폐쇄 트랜잭션에 서명하고 브로드캐스팅하면 채널이 닫힌다.

### 협력적 폐쇄 트랜잭션 

협력적 폐쇄 트랜잭션은 앨리스와 밥이 합의했던 마지막 약정 트랜잭션과 비슷해 보이지만 출력에 타임락이나 페널티를 위한 철회 키가 없다. 두 당사자가 협력하여 이 트랜잭션을 생성하고 더 이상의 약정을 하지 않기 때문에, 이 트랜잭션에는 비대칭, 지연, 철회 가능한 요소가 필요하지 않다.

일반적으로 이 협력 폐쇄 트랜잭션에 사용되는 주소는 폐쇄되는 각 채널에 마다 새로 생성된다. 그러나 양측이 협력적으로 정산한 자금을 전송하는 데 사용할 "배달" 주소를 고정할 수도 있다. `open_channel` 및 `accept_channel` 메시지의 TLV 네임스페이스 내에 양쪽 모두 "사전 종료 스크립트(up-front shutdown script)"를 자유롭게 지정할 수 있다. (미리 정산받을 주소를 지정해놓는 것을 말함.) 일반적으로 이 주소는 콜드 스토리지에 있는 키에서 파생된다. 이 방식은 채널 파트너가 해킹 당할 경우 해커가 자신이 제어하는 주소를 사용하여 협력적으로 채널을 폐쇄할 수 없으므로 채널의 보안을 강화하는 데 도움이 된다. 대신, 타협하지 않는 정직한 채널 파트너는 지정된 사전 종료 주소를 사용하지 않는 경우 채널 폐쇄에 협조하지 않는다. 이 기능은 효과적으로 '폐쇄 루프'를 생성하여 특정 채널에서 자금이 유출되는 것을 막는다.

앨리스는 채널 폐쇄를 위해 트랜잭션을 브로드캐스팅한다.

  <figure>
    <img src="https://github.com/lnbook/lnbook/raw/develop/images/mtln_0716.png" width="800">
      그림 16. 협력적 폐쇄 트랜잭션
  </figure>

<br/>
<br/>
비트코인 블록체인에서 이 폐쇄 트랜잭션이 승인 되는 즉시 채널이 닫힌다. 이제 앨리스와 밥은 인출금을 사용할 수 있다.

<br>

## 결론

지금까지 결제 채널을 자세히 살펴보았다. 앨리스와 밥이 펀딩, 약정, 채널 폐쇄를 협상하는 데 사용한 세 가지 메시지 흐름을 살펴보았고 펀딩, 약정, 거래 완료의 구조와 철회 및 페널티 메커니즘도 살펴보았다.

다음 몇 장에서 걸쳐 살펴보겠지만, 채널 파트너 간의 로컬 결제에도 HTLC(Hashed TimeLock Contract)가 사용된다. 반드시 필요한 것은 아니지만, 한 채널만 사용하는 로컬 결제와 여러 채널을 사용하는 라우팅 결제를 동일한 방식으로 사용할 수 있으면 프로토콜이 훨씬 간단해진다.

단일 결제 채널에서 초당 결제 건수는 앨리스와 밥 사이의 네트워크 용량에 의해서만 제한된다. 채널 파트너가 새로운 채널 잔액에 동의하기 위해 몇 바이트의 데이터만 주고받을 수 있다면 사실상 결제가 완료되는 것이다. 이것이 바로 비트코인 블록체인(온체인)에서 처리할 수 있는 트랜잭션 처리량보다 라이트닝 네트워크(오프체인)에서 훨씬 더 많은 결제 처리량을 달성할 수 있는 이유이다.

다음 몇 장에서는 채널 운영 시의 라우팅, HTLC, 그리고 채널 사용에 대해 설명한다.